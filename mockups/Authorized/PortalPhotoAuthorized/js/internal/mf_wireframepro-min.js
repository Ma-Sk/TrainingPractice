try { if (!Object.prototype.__defineGetter__ && Object.defineProperty({}, 'x', { get() { return true; } }).x) { Object.defineProperty(Object.prototype, '__defineGetter__', { enumerable: false, configurable: true, value(name, func) { Object.defineProperty(this, name, { get: func, enumerable: true, configurable: true }); } }); Object.defineProperty(Object.prototype, '__defineSetter__', { enumerable: false, configurable: true, value(name, func) { Object.defineProperty(this, name, { set: func, enumerable: true, configurable: true }); } }); } } catch (defPropException) {} function getInternetExplorerVersion() { try { const sAgent = window.navigator.userAgent; const Idx = sAgent.indexOf('MSIE'); if (Idx > 0) { return parseInt(sAgent.substring(Idx + 5, sAgent.indexOf('.', Idx))); } if (navigator.userAgent.match(/Trident\/7\./)) { return 11; } return 0; } catch (err) {} return null; } function checkIEVersion() { try { const ver = getInternetExplorerVersion(); if (ver > 0) { if (confirm("ALERT! You're using an OLD Unsupported version of Windows Internet Explorer. Only IE Edge and above are supported.")) { window.location = 'https://mockflow.com'; } else { window.location = 'https://mockflow.com'; } } } catch (err) {} } var MF_Global = (function () {
  function privateMethod() {} return {
    serverURL() { return 'https://wireframepro.mockflow.com/'; }, cdnURL() { return 'https://d20hhedk3h2l88.cloudfront.net/apps/wireframepro/'; }, getS3Bucket() { return 'assets.mockflow.com'; }, getCompPath() { const comppath = 'https://wireframepro.mockflow.com/js/internal/editor/components/'; return comppath; }, getMode() { return 'PROD'; }, getS3URL() { return `https://s3.amazonaws.com/${MF_Global.getS3Bucket()}/`; }, getS3ProdURL() { return 'https://s3.amazonaws.com/assets.mockflow.com/'; },
  };
}()); function MF_Project() { const thisClass = this; this.id = null; this.title = null; this.creator = null; this.createDate = null; this.updateDate = null; this.share = false; this.shareDisabled = false; this.isBasic = true; this.permitted = false; this.sharedClient = null; this.permissionType = null; this.realtime = false; this.revision = false; this.stamp = null; this.checkPermission = false; this.comments = 0; this.members = 0; this.data = null; this.published = false; this.flash = false; this.width = 300; this.height = 250; this.collaborators = null; this.collaboratorsOld = null; this.sharePerm = null; this.sharePermOld = null; this.pages = new Array(); this.emailAlert = true; this.company = null; this.font = null; this.category = null; this.publicURL = null; this.urlview = null; this.setCollaborators = function (arr) { if (thisClass.flash) { thisClass.collaboratorsOld = arr; } else { thisClass.collaborators = arr; } }; this.getCollaborators = function () { if (thisClass.flash) { return thisClass.collaboratorsOld; } return thisClass.collaborators; }; let creatorImage = ''; this.__defineGetter__('creatorImage', () => { let cr = thisClass.creator; if (cr == 'mockflow@produle.com') { cr = 'dummymf'; } const str = MF_Utils.get_gravatar(cr, 32); return str; }); this.__defineSetter__('creatorImage', (val) => { creatorImage = val; }); this.__defineSetter__('isShared', (val) => {}); this.__defineGetter__('isShared', () => { if (thisClass.permissionTypeStr == 'Owner') { return ''; } return true; }); let createDateStr = ''; this.__defineGetter__('createDateStr', () => { if (thisClass.createDate != null) { const curr_date = thisClass.createDate.getDate(); const curr_month = thisClass.createDate.getMonth() + 1; const curr_year = thisClass.createDate.getFullYear(); const hours = thisClass.createDate.getHours(); const minutes = thisClass.createDate.getMinutes(); return `${curr_date} ${MF_Utils.getMonthByName(thisClass.createDate.getMonth())} ${curr_year} - ${hours}:${minutes}`; } return thisClass.createDate; }); this.__defineSetter__('createDateStr', (val) => { createDateStr = val; }); let updateDateStr = ''; this.__defineGetter__('updateDateStr', () => { if (thisClass.updateDate != null) { const curr_date = thisClass.updateDate.getDate(); const curr_month = thisClass.updateDate.getMonth() + 1; const curr_year = thisClass.updateDate.getFullYear(); const hours = thisClass.updateDate.getHours(); const minutes = thisClass.updateDate.getMinutes(); return `${curr_date} ${MF_Utils.getMonthByName(thisClass.updateDate.getMonth())} ${curr_year} - ${hours}:${minutes}`; } return thisClass.updateDate; }); this.__defineSetter__('updateDateStr', (val) => { updateDateStr = val; }); let shareStr = 'no'; this.__defineGetter__('shareStr', () => { if (thisClass.share) { return 'yes'; } return 'no'; }); this.__defineSetter__('shareStr', (val) => { shareStr = val; }); let permissionTypeStr = 'owner'; this.__defineGetter__('permissionTypeStr', () => { if (thisClass.permissionType == null) { return 'Owner'; } if (thisClass.permissionType == 'Editor') { return 'Designer'; } return thisClass.permissionType; }); this.__defineSetter__('permissionTypeStr', (val) => { permissionTypeStr = val; }); let publishedStr = 'No'; this.__defineGetter__('publishedStr', () => { if (thisClass.published == true) { return 'Yes'; } return 'No'; }); this.__defineSetter__('publishedStr', (val) => { publishedStr = val; }); let thumbnailURL = ''; this.__defineGetter__('thumbnailURL', () => { if (thisClass.flash) { if (thisClass.permitted) { return MF_Global.mockupSharedImageURL(thisClass.company) + thisClass.id; } return MF_Global.mockupImageURL() + thisClass.id; } return `https://s3.amazonaws.com/${MF_Global.getS3Bucket()}/app/wireframepro/company/${thisClass.company}/projects/${thisClass.id}/thumbnail/${thisClass.id}`; }); this.__defineSetter__('thumbnailURL', (val) => { thumbnailURL = val; }); let imageURL = ''; this.__defineGetter__('imageURL', () => { if (MF_Global.getMode() == 'PROD') { return `http://assets.mockflow.com/app/wireframepro/company/${thisClass.company}/projects/${thisClass.id}/image/${thisClass.id}`; } return `https://s3.amazonaws.com/${MF_Global.getS3Bucket()}/app/wireframepro/company/${thisClass.company}/projects/${thisClass.id}/image/${thisClass.id}`; }); this.__defineSetter__('imageURL', (val) => { imageURL = val; }); this.cast = function (obj) { this.id = obj.id; this.title = obj.title; this.creator = obj.creator; this.createDate = obj.createDate; this.updateDate = obj.updateDate; this.publicURL = obj.publicURL; this.share = obj.share; this.urlview = obj.urlview; this.shareDisabled = obj.shareDisabled; this.isBasic = obj.isBasic; this.permitted = obj.permitted; this.sharedClient = obj.shareClient; this.permissionType = obj.permissionType; this.realtime = obj.realtime; this.revision = obj.revision; this.stamp = obj.stamp; this.checkPermission = obj.checkPermission; this.comments = obj.comments; this.members = obj.members; this.data = obj.data; this.font = obj.font; this.category = obj.category; this.published = obj.published; this.collaborators = obj.collaborators; this.collaboratorsOld = obj.collaboratorsOld; this.company = obj.company; this.sharePerm = obj.sharePerm; this.sharePermOld = obj.sharePermOld; this.flash = obj.flash; this.pages = obj.pages; }; } function MF_ComponentItem() { const thisClass = this; this.n = null; this.l = null; this.db = false; this.__defineSetter__('thumbnail', (val) => {}); this.__defineGetter__('thumbnail', () => { if (thisClass.db) { return `${MF_Global.getS3ProdURL()}app/wireframepro/dbcomponents/thumbnails/${thisClass.n}.png`; } return `${MF_Global.getS3ProdURL()}app/wireframepro/components/thumbnails/${thisClass.n}.png`; }); this.cast = function (obj) { this.n = obj.n; this.l = obj.l; this.db = obj.db; }; } function MF_MultiLinkObj() { const thisClass = this; this.id = null; this.item = null; this.page = null; this.pageLabel = null; this.count = 0; this.isLinked = false; this.linkVal = ''; this.url = null; } function MF_MultiIconObj() { const thisClass = this; this.id = null; this.item = null; this.iconCls = ''; this.count = 0; this.isIcon = false; } function MF_LinkObj() { const thisClass = this; this.event = null; this.type = null; this.url = null; this.pageName = null; } function MF_PageData() { const thisClass = this; this.eid = null; this.projectid = null; this.clientid = null; this.compressedData = null; this.data = null; this.createDate = null; this.updateDate = null; this.stamp = null; this.comments = 0; this.name = null; this.sortorder = -1; this.snapped = false; this.cast = function (obj) { this.eid = obj.eid; this.projectid = obj.projectid; this.clientid = obj.clientid; this.compressedData = obj.compressedData; this.data = obj.data; this.createDate = obj.createDate; this.updateDate = obj.updateDate; this.stamp = obj.stamp; this.comments = obj.comments; this.sortorder = obj.sortorder; this.name = obj.name; this.snapped = obj.snapped; }; } function MF_Component() { const thisClass = this; this.name = null; this.category = null; this.label = null; this.cast = function (obj) { this.name = obj.name; this.category = obj.category; this.label = obj.label; }; } function MF_Font() { const thisClass = this; this.type = null; this.id = null; this.name = null; this.isGoogleFont = false; this.cast = function (obj) { this.type = obj.type; this.id = obj.id; this.name = obj.name; this.isGoogleFont = obj.isGoogleFont; }; } function MF_SharePerm() { const thisClass = this; this.canDuplicateProject = false; this.canChat = true; this.canViewLog = true; this.canViewMembers = true; this.canUploadImage = true; this.canDeleteImage = true; this.canPreviewRevision = true; this.canDeleteRevision = true; this.canChangeSiteMap = true; this.canExportData = false; this.cast = function (obj) { this.canDuplicateProject = obj.canDuplicateProject; this.canChat = obj.canChat; this.canViewLog = obj.canViewLog; this.canViewMembers = obj.canViewMembers; this.canUploadImage = obj.canUploadImage; this.canDeleteImage = obj.canDeleteImage; this.canPreviewRevision = obj.canPreviewRevision; this.canDeleteRevision = obj.canDeleteRevision; this.canChangeSiteMap = obj.canChangeSiteMap; this.canExportData = obj.canExportData; }; } function MF_Image() { const thisClass = this; this.id = null; this.name = null; this.type = null; this.creator = null; this.createDate = null; this.width = 0; this.height = 0; this.projectid = null; this.clientid = null; let thumbnailURL = ''; this.__defineGetter__('thumbnailURL', () => `${MF_Global.getS3URL()}app/wireframepro/company/${thisClass.clientid}/projects/${thisClass.projectid}/images/thumbnails/${thisClass.id}`); this.__defineSetter__('thumbnailURL', (val) => { thumbnailURL = val; }); let imageURL = ''; this.__defineGetter__('imageURL', () => `${MF_Global.getS3URL()}app/wireframepro/company/${thisClass.clientid}/projects/${thisClass.projectid}/images/${thisClass.id}`); this.__defineSetter__('imageURL', (val) => { imageURL = val; }); this.cast = function (obj) { this.id = obj.id; this.name = obj.name; this.type = obj.type; this.creator = obj.creator; this.createDate = obj.createDate; this.width = obj.width; this.height = obj.height; this.projectid = obj.projectid; this.clientid = obj.clientid; }; } function MF_MeshGrid() { const thisClass = this; this.type = 'mesh'; this.lineColor = '#cccccc'; this.snap = true; this.size = 20; this.position = 'behind'; this.showInViewer = false; this.getXML = function () { let xml = '<grid '; xml += " type='mesh' "; xml = `${xml} lineColor='${thisClass.lineColor}' `; xml = `${xml} snap=${thisClass.snap.toString()}`; +' '; xml = `${xml} showInViewer=${thisClass.showInViewer.toString()}`; +' '; xml = `${xml} size=${thisClass.size} `; xml = `${xml} position='${thisClass.position}' `; xml += ' ></grid>'; return xml; }; this.setXML = function (xmlobj) { thisClass.lineColor = xmlobj.attr('lineColor'); thisClass.position = xmlobj.attr('position'); if (xmlobj.attr('snap') == 'true') { thisClass.snap = true; } else { thisClass.snap = false; } if (xmlobj.attr('showInViewer') == 'true') { thisClass.showInViewer = true; } else { thisClass.showInViewer = false; }thisClass.size = parseInt(xmlobj.attr('size')); }; this.cast = function (obj) { thisClass.lineColor = obj.lineColor; thisClass.snap = obj.snap; thisClass.size = obj.size; thisClass.position = obj.position; thisClass.showInViewer = obj.showInViewer; }; this.setGrid = function (count) { if (mf_main.RENDER || mf_main.REVISION) { return; } if (mf_main.editorController.VIEWER && thisClass.showInViewer == false) { $('#mfGrid').remove(); return; }$('#mfGrid').remove(); const htmldiv = `<div id='mfGrid' style='position: absolute; pointer-events: none; width: 100%; height: 100%; background-color: transparent; background-size: ${thisClass.size}px ${thisClass.size}px; background-image: linear-gradient(to right, ${thisClass.lineColor} 1px, transparent 1px), linear-gradient(to bottom, ${thisClass.lineColor}  1px, transparent 1px); '></div>`; if (thisClass.position == 'behind') { $('#mfContainerPage').prepend(htmldiv); } else { $('#mfContainerPage').append(htmldiv); $('#mfGrid').css('z-index', mf_main.editorController.loadedPages.length + 10); } }; } function MF_960Grid() { const thisClass = this; this.type = '960'; this.columnColor = '#f44336'; this.columnSize = 60; this.gutterSize = 10; this.position = 'behind'; this.showInViewer = false; this.getXML = function () { let xml = '<grid '; xml += " type='960' "; xml = `${xml} columnColor='${thisClass.columnColor}' `; xml = `${xml} showInViewer=${thisClass.showInViewer.toString()}`; +' '; xml = `${xml} columnSize=${thisClass.columnSize} `; xml = `${xml} gutterSize=${thisClass.gutterSize} `; xml = `${xml} position='${thisClass.position}' `; xml += ' ></grid>'; return xml; }; this.cast = function (obj) { thisClass.columnColor = obj.columnColor; thisClass.columnSize = obj.columnSize; thisClass.gutterSize = obj.gutterSize; thisClass.position = obj.position; thisClass.showInViewer = obj.showInViewer; }; this.setXML = function (xmlobj) { thisClass.columnColor = xmlobj.attr('columnColor'); thisClass.position = xmlobj.attr('position'); if (xmlobj.attr('showInViewer') == 'true') { thisClass.showInViewer = true; } else { thisClass.showInViewer = false; }thisClass.columnSize = parseInt(xmlobj.attr('columnSize')); thisClass.gutterSize = parseInt(xmlobj.attr('gutterSize')); }; this.setGrid = function (count) { if (mf_main.RENDER || mf_main.REVISION) { return; } if (mf_main.editorController.VIEWER && thisClass.showInViewer == false) { $('#mfGrid').remove(); return; }$('#mfGrid').remove(); const colcolorrgb = MF_ComponentUtils.hexToRGB(thisClass.columnColor, 0.2); const htmldiv = `<div id='mfGrid' style='position: absolute; pointer-events: none; width: 100%; height: 100%; background-color: transparent; background-size: ${thisClass.columnSize + thisClass.gutterSize}px ${thisClass.columnSize + thisClass.gutterSize}px; background-image: linear-gradient(90deg, transparent ${thisClass.gutterSize}px, ${colcolorrgb} ${thisClass.gutterSize}px); '></div>`; if (thisClass.position == 'behind') { $('#mfContainerPage').prepend(htmldiv); } else { $('#mfContainerPage').append(htmldiv); $('#mfGrid').css('z-index', mf_main.editorController.loadedPages.length + 10); } }; } var MF_Utils = (function () {
  function privateMethod() {} return {
    getUser() { return user; },
    slideInDown(did) { $('#tmDialogBackground').show(0, onDivShow); function onDivShow() { $(did).css('display', 'block'); tm_main.interfaceResize(); $(did).css({ position: 'absolute', top: -($(did).height()) }); $(did).animate({ top: `${0}px` }, { duration: 200, complete() {} }); } },
    convertUndefinedPropToEmptyString(object) { for (const key in object) { if (typeof object[key] === undefined || object[key] == 'undefined') { object[key] = ''; } } },
    htmlEscape(str) {
      if (str != '' && str) {
        return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      } return '';
    },
    htmlUnescape(str) {
      if (str != '' && str) {
        return String(str).replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&amp;/g, '&');
      } return '';
    },
    loadsScripts(path) { const paths = path.map(scr => $.getScript(scr)); paths.push($.Deferred((deferred) => { $(deferred.resolve); })); return $.when(...paths); },
    guidGenerator() { const S4 = function () { return (((1 + Math.random()) * 65536) | 0).toString(16).substring(1); }; return `D${S4() + S4() + S4() + S4() + S4() + S4() + S4() + S4()}`; },
    resolveUrls(feedbackMsg) {
      let resolvedMsg = feedbackMsg; const urlPattern = /\b(https?:\/\/)?[a-zA-Z0-9\/\-:]+(\.[a-z0-9-+&@#\/%?=~_|!:,;]+)+/gi; const protocolList = /^((https?):\/\/)/i; const linkTemplate = "<a href='{0}' target='_blank'>{0}</a>"; let urlList = urlPattern.exec(feedbackMsg),
        currentUrl = ''; while (urlList !== null) { currentUrl = urlList[0]; if (!protocolList.test(currentUrl)) { currentUrl = `http://${currentUrl}`; }resolvedMsg = resolvedMsg.replace(urlList[0], linkTemplate.replace('{0}', currentUrl).replace('{0}', urlList[0])); urlList = urlPattern.exec(feedbackMsg); } return resolvedMsg;
    },
    getParameterByName(name, url) {
      if (!url) { url = window.location.href; }name = name.replace(/[\[\]]/g, '\\$&'); let regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),
        results = regex.exec(url); if (!results) { return null; } if (!results[2]) { return ''; } return decodeURIComponent(results[2].replace(/\+/g, ' '));
    },
    xmlToString(xmlData) { let xmlString = null; try { if (window.ActiveXObject) { xmlString = xmlData.xml; } else { const oSerializer = new XMLSerializer(); xmlString = oSerializer.serializeToString(xmlData[0]); } } catch (e) { xmlString = ''; } return xmlString; },
    computePoints(startType, x, y, width, height) { const obj = new Object(); if (startType == 'topLeft') { obj.startx = x; obj.starty = y; obj.endx = x + width; obj.endy = y + height; } if (startType == 'topRight') { obj.startx = x + width; obj.starty = y; obj.endx = x; obj.endy = y + height; } if (startType == 'bottomLeft') { obj.startx = x; obj.starty = y + height; obj.endx = x + width; obj.endy = y; } if (startType == 'bottomRight') { obj.startx = x + width; obj.starty = y + height; obj.endx = x; obj.endy = y; } return obj; },
    pointTransform(point, center, angle) { const theta = angle * (Math.PI / 180); point.x -= center.x; point.y -= center.y; return { x: (point.x * Math.cos(theta * -1) + point.y * Math.sin(theta * -1)) + center.x, y: (point.x * Math.sin(theta) + point.y * Math.cos(theta)) + center.y }; },
    getBooleanString(val) { if (val) { return 'true'; } return 'false'; },
    rotate(id, angle) { $(`#${id}`).css('-moz-transform', `rotate(${angle}deg)`); $(`#${id}`).css('-webkit-transform', `rotate(${angle}deg)`); $(`#${id}`).css('-o-transform', `rotate(${angle}deg)`); $(`#${id}`).css('-ms-transform', `rotate(${angle}deg)`); $(`#${id}`).css('transform', `rotate(${angle}deg)`); },
    calculateDimensions(startx, starty, endx, endy, delta) { const dim = new Object(); if (endy > starty) { dim.y = starty; dim.height = endy - starty; dim.starty = delta; dim.endy = dim.height + delta; } else { dim.y = endy; dim.height = starty - endy; dim.starty = dim.height + delta; dim.endy = delta; } if (endx > startx) { dim.x = startx; dim.width = endx - startx; dim.startx = delta; dim.endx = dim.width + delta; } else { dim.x = endx; dim.width = startx - endx; dim.startx = dim.width + delta; dim.endx = delta; } if (dim.x > startx || dim.x > endx) { dim.x -= dim.width; } if (dim.y > starty || dim.y > endy) { dim.y -= dim.height; }dim.startType = 'topRight'; const sx = dim.startx; const sy = dim.starty; if (sx == delta && sy == delta) { dim.startType = 'topLeft'; } if (sx == (dim.width + delta) && sy == delta) { dim.startType = 'topRight'; } if (sx == delta && sy == (dim.height + delta)) { dim.startType = 'bottomLeft'; } if (sx == (dim.width + delta) && sy == (dim.height + delta)) { dim.startType = 'bottomRight'; } return dim; },
    trim(s) { let l = 0; let r = s.length - 1; while (l < s.length && s[l] == ' ') { l++; } while (r > l && s[r] == ' ') { r -= 1; } return s.substring(l, r + 1); },
    getCheckBoxValue(chkID) { if ($(`#${chkID}`).is(':checked')) { return true; } return false; },
    localToGlobal(_el) {
      let target = _el,
        target_width = target.offsetWidth,
        target_height = target.offsetHeight,
        target_left = target.offsetLeft,
        target_top = target.offsetTop,
        gleft = 0,
        gtop = 0,
        rect = {}; var moonwalk = function (_parent) {
        if (_parent) { gleft += _parent.offsetLeft; gtop += _parent.offsetTop; moonwalk(_parent.offsetParent); } else {
          return rect = {
            top: target.offsetTop + gtop, left: target.offsetLeft + gleft, bottom: (target.offsetTop + gtop) + target_height, right: (target.offsetLeft + gleft) + target_width,
          };
        }
      }; moonwalk(target.offsetParent); return rect;
    },
    globalToLocalPoint(e, elementid) { if ($(`#${elementid}`).length) { const localoffsetX = $(`#${elementid}`).offset().left; const localoffsetY = $(`#${elementid}`).offset().top; const localx = Math.floor(e.pageX - localoffsetX); const localy = Math.floor(e.pageY - localoffsetY); var lpt = new Object(); lpt.x = localx; lpt.y = localy; return lpt; } var lpt = new Object(); lpt.x = 0; lpt.y = 0; return lpt; },
    globalToLocalPoint2(x, y, elementid) { if ($(`#${elementid}`).length) { const localoffsetX = $(`#${elementid}`).offset().left; const localoffsetY = $(`#${elementid}`).offset().top; const localx = Math.floor(x - localoffsetX); const localy = Math.floor(y - localoffsetY); var lpt = new Object(); lpt.x = localx; lpt.y = localy; return lpt; } var lpt = new Object(); lpt.x = 0; lpt.y = 0; return lpt; },
    localToGlobalPoint(xpt, ypt, elementid) { if ($(`#${elementid}`).length) { const localoffsetX = $(`#${elementid}`).offset().left; const localoffsetY = $(`#${elementid}`).offset().top; const localx = Math.floor(xpt + localoffsetX); const localy = Math.floor(ypt + localoffsetY); var lpt = new Object(); lpt.x = localx; lpt.y = localy; return lpt; } var lpt = new Object(); lpt.x = 0; lpt.y = 0; return lpt; },
    getMonthByName(num) { const m_names = new Array('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'); return m_names[num]; },
    htmlEncode(val) { return $('<div/>').text(val).html(); },
    htmlDecode(val) { return $('<div/>').html(val).text(); },
    isValidEmailAddress(emailAddress) { const pattern2 = new RegExp(/^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i); return pattern2.test(emailAddress); },
    findPos(obj) { let curleft = curtop = 0; if (obj.offsetParent) { curleft = obj.offsetLeft; curtop = obj.offsetTop; while (obj = obj.offsetParent) { curleft += obj.offsetLeft; curtop += obj.offsetTop; } } return [curleft, curtop]; },
    display_ActionIndicator(msg) { $('#mfActionIndicator').css({ position: 'absolute', top: 0, left: (($(window).width() / 2) - ($('#mfActionIndicator').width() / 2)) }); $('#mfActionIndicatorMessage').text(msg); $('#mfActionIndicator').fadeTo('fast', 1); setTimeout(() => { $('#mfActionIndicator').css('display', 'none'); }, 1000); },
    display_menu(parent, named, e) { const menu_element = document.getElementById(named); menu_element.style.display = ''; menu_element.style.left = `${e.pageX}px`; menu_element.style.top = `${e.pageY}px`; if ((e.pageY + 10 + $(`#${named}`).height()) > $(window).height()) { menu_element.style.top = `${e.pageY - $(`#${named}`).height()}px`; } },
    hide_menu(named) { const menu_element = document.getElementById(named); if (menu_element) { menu_element.style.display = 'none'; } },
    roundedRect2(ctx, x, y, w, h, cornerRadius) {
      cornerRadius /= 2; ctx.beginPath(); let theta,
        angle,
        cx,
        cy,
        px,
        py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + w - cornerRadius, y); angle = -Math.PI / 2; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + w, y + h - cornerRadius); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + cornerRadius, y + h); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x, y + cornerRadius); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.stroke();
    },
    roundedRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height - radius); ctx.quadraticCurveTo(x, y + height, x + radius, y + height); ctx.lineTo(x + width - radius, y + height); ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); ctx.stroke(); },
    RGBToHex(color) { if (color.substr(0, 1) === '#') { return color; } const digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color); const red = parseInt(digits[2]); const green = parseInt(digits[3]); const blue = parseInt(digits[4]); return `#${MF_Utils.toHex(red)}${MF_Utils.toHex(green)}${MF_Utils.toHex(blue)}`; },
    toHex(N) { if (N == null) { return '00'; }N = parseInt(N); if (N == 0 || isNaN(N)) { return '00'; }N = Math.max(0, N); N = Math.min(N, 255); N = Math.round(N); return '0123456789ABCDEF'.charAt((N - N % 16) / 16) + '0123456789ABCDEF'.charAt(N % 16); },
    hexToRGB(hex, alpha) { alpha = typeof (alpha) !== 'undefined' ? alpha : '1'; const rgbObj = { red: ((hex & 16711680) >> 16), green: ((hex & 65280) >> 8), blue: ((hex & 255)) }; return `rgba(${rgbObj.red},${rgbObj.green},${rgbObj.blue},${alpha})`; },
    randomInRange(min, max) { const scale = max - min; return Math.floor(Math.random() * scale + min); },
    get_gravatar(email, size) {
      const MD5 = function (s) {
        function L(k, d) { return (k << d) | (k >>> (32 - d)); } function K(G, k) {
          let I,
            d,
            F,
            H,
            x; F = (G & 2147483648); H = (k & 2147483648); I = (G & 1073741824); d = (k & 1073741824); x = (G & 1073741823) + (k & 1073741823); if (I & d) { return (x ^ 2147483648 ^ F ^ H); } if (I | d) { if (x & 1073741824) { return (x ^ 3221225472 ^ F ^ H); } return (x ^ 1073741824 ^ F ^ H); } return (x ^ F ^ H);
        } function r(d, F, k) { return (d & F) | ((~d) & k); } function q(d, F, k) { return (d & k) | (F & (~k)); } function p(d, F, k) { return (d ^ F ^ k); } function n(d, F, k) { return (F ^ (d | (~k))); } function u(G, F, aa, Z, k, H, I) { G = K(G, K(K(r(F, aa, Z), k), I)); return K(L(G, H), F); } function f(G, F, aa, Z, k, H, I) { G = K(G, K(K(q(F, aa, Z), k), I)); return K(L(G, H), F); } function D(G, F, aa, Z, k, H, I) { G = K(G, K(K(p(F, aa, Z), k), I)); return K(L(G, H), F); } function t(G, F, aa, Z, k, H, I) { G = K(G, K(K(n(F, aa, Z), k), I)); return K(L(G, H), F); } function e(G) { let Z; const F = G.length; const x = F + 8; const k = (x - (x % 64)) / 64; const I = (k + 1) * 16; const aa = Array(I - 1); let d = 0; let H = 0; while (H < F) { Z = (H - (H % 4)) / 4; d = (H % 4) * 8; aa[Z] = (aa[Z] | (G.charCodeAt(H) << d)); H++; }Z = (H - (H % 4)) / 4; d = (H % 4) * 8; aa[Z] = aa[Z] | (128 << d); aa[I - 2] = F << 3; aa[I - 1] = F >>> 29; return aa; } function B(x) {
          let k = '',
            F = '',
            G,
            d; for (d = 0; d <= 3; d++) { G = (x >>> (d * 8)) & 255; F = `0${G.toString(16)}`; k += F.substr(F.length - 2, 2); } return k;
        } function J(k) { k = k.replace(/rn/g, 'n'); let d = ''; for (let F = 0; F < k.length; F++) { const x = k.charCodeAt(F); if (x < 128) { d += String.fromCharCode(x); } else if ((x > 127) && (x < 2048)) { d += String.fromCharCode((x >> 6) | 192); d += String.fromCharCode((x & 63) | 128); } else { d += String.fromCharCode((x >> 12) | 224); d += String.fromCharCode(((x >> 6) & 63) | 128); d += String.fromCharCode((x & 63) | 128); } } return d; } let C = Array(); let P,
          h,
          E,
          v,
          g,
          Y,
          X,
          W,
          V; let S = 7,
          Q = 12,
          N = 17,
          M = 22; let A = 5,
          z = 9,
          y = 14,
          w = 20; let o = 4,
          m = 11,
          l = 16,
          j = 23; let U = 6,
          T = 10,
          R = 15,
          O = 21; s = J(s); C = e(s); Y = 1732584193; X = 4023233417; W = 2562383102; V = 271733878; for (P = 0; P < C.length; P += 16) { h = Y; E = X; v = W; g = V; Y = u(Y, X, W, V, C[P + 0], S, 3614090360); V = u(V, Y, X, W, C[P + 1], Q, 3905402710); W = u(W, V, Y, X, C[P + 2], N, 606105819); X = u(X, W, V, Y, C[P + 3], M, 3250441966); Y = u(Y, X, W, V, C[P + 4], S, 4118548399); V = u(V, Y, X, W, C[P + 5], Q, 1200080426); W = u(W, V, Y, X, C[P + 6], N, 2821735955); X = u(X, W, V, Y, C[P + 7], M, 4249261313); Y = u(Y, X, W, V, C[P + 8], S, 1770035416); V = u(V, Y, X, W, C[P + 9], Q, 2336552879); W = u(W, V, Y, X, C[P + 10], N, 4294925233); X = u(X, W, V, Y, C[P + 11], M, 2304563134); Y = u(Y, X, W, V, C[P + 12], S, 1804603682); V = u(V, Y, X, W, C[P + 13], Q, 4254626195); W = u(W, V, Y, X, C[P + 14], N, 2792965006); X = u(X, W, V, Y, C[P + 15], M, 1236535329); Y = f(Y, X, W, V, C[P + 1], A, 4129170786); V = f(V, Y, X, W, C[P + 6], z, 3225465664); W = f(W, V, Y, X, C[P + 11], y, 643717713); X = f(X, W, V, Y, C[P + 0], w, 3921069994); Y = f(Y, X, W, V, C[P + 5], A, 3593408605); V = f(V, Y, X, W, C[P + 10], z, 38016083); W = f(W, V, Y, X, C[P + 15], y, 3634488961); X = f(X, W, V, Y, C[P + 4], w, 3889429448); Y = f(Y, X, W, V, C[P + 9], A, 568446438); V = f(V, Y, X, W, C[P + 14], z, 3275163606); W = f(W, V, Y, X, C[P + 3], y, 4107603335); X = f(X, W, V, Y, C[P + 8], w, 1163531501); Y = f(Y, X, W, V, C[P + 13], A, 2850285829); V = f(V, Y, X, W, C[P + 2], z, 4243563512); W = f(W, V, Y, X, C[P + 7], y, 1735328473); X = f(X, W, V, Y, C[P + 12], w, 2368359562); Y = D(Y, X, W, V, C[P + 5], o, 4294588738); V = D(V, Y, X, W, C[P + 8], m, 2272392833); W = D(W, V, Y, X, C[P + 11], l, 1839030562); X = D(X, W, V, Y, C[P + 14], j, 4259657740); Y = D(Y, X, W, V, C[P + 1], o, 2763975236); V = D(V, Y, X, W, C[P + 4], m, 1272893353); W = D(W, V, Y, X, C[P + 7], l, 4139469664); X = D(X, W, V, Y, C[P + 10], j, 3200236656); Y = D(Y, X, W, V, C[P + 13], o, 681279174); V = D(V, Y, X, W, C[P + 0], m, 3936430074); W = D(W, V, Y, X, C[P + 3], l, 3572445317); X = D(X, W, V, Y, C[P + 6], j, 76029189); Y = D(Y, X, W, V, C[P + 9], o, 3654602809); V = D(V, Y, X, W, C[P + 12], m, 3873151461); W = D(W, V, Y, X, C[P + 15], l, 530742520); X = D(X, W, V, Y, C[P + 2], j, 3299628645); Y = t(Y, X, W, V, C[P + 0], U, 4096336452); V = t(V, Y, X, W, C[P + 7], T, 1126891415); W = t(W, V, Y, X, C[P + 14], R, 2878612391); X = t(X, W, V, Y, C[P + 5], O, 4237533241); Y = t(Y, X, W, V, C[P + 12], U, 1700485571); V = t(V, Y, X, W, C[P + 3], T, 2399980690); W = t(W, V, Y, X, C[P + 10], R, 4293915773); X = t(X, W, V, Y, C[P + 1], O, 2240044497); Y = t(Y, X, W, V, C[P + 8], U, 1873313359); V = t(V, Y, X, W, C[P + 15], T, 4264355552); W = t(W, V, Y, X, C[P + 6], R, 2734768916); X = t(X, W, V, Y, C[P + 13], O, 1309151649); Y = t(Y, X, W, V, C[P + 4], U, 4149444226); V = t(V, Y, X, W, C[P + 11], T, 3174756917); W = t(W, V, Y, X, C[P + 2], R, 718787259); X = t(X, W, V, Y, C[P + 9], O, 3951481745); Y = K(Y, h); X = K(X, E); W = K(W, v); V = K(V, g); } const i = B(Y) + B(X) + B(W) + B(V); return i.toLowerCase();
      }; var size = size || 80; return `https://www.gravatar.com/avatar/${MD5(email)}.jpg?d=mm&rating=G&s=${size}`;
    },
  };
}()); function MF_Main() { const thisClass = this; this.UID = MF_Utils.guidGenerator(); this.PUBLICID = ''; this.projectID = null; this.EXPORTHTML = true; this.RENDER = false; this.REVISION = false; this.revisionID = null; this.pageID = null; this.clientID = null; this.pageID = null; this.editorController = new MF_EditorController(); this.componentList = new MF_ComponentList(); this.PERMISSION = 'Owner'; this.PUBLIC = false; this.cachedTemplates = new Object(); this.onLoadInterface = function () { $('#mainBody').show(); if (mf_main.PUBLIC || mf_main.RENDER) { $.address.change((event) => {}); $.address.init((event) => { let pageid = ''; let sidebar = 'on'; for (let i = 0; i < event.pathNames.length; i++) { const val = event.pathNames[i]; if (val == 'page') { if ((i + 1) <= event.pathNames.length) { pageid = event.pathNames[i + 1]; } } if (val == 'sidebar') { if ((i + 1) <= event.pathNames.length) { sidebar = event.pathNames[i + 1]; } } } if (pageid != '' && pageid != null) { thisClass.pageID = pageid; } if (sidebar != '' && sidebar != null) { if (sidebar == 'off') { mf_main.editorController.hideNavBar(); } } }); }$(document).bind('click', () => { $('.dropdowncomp_content').hide(); }); function onAnimate(show) { if (show) { $(this).slideDown(100, 'easeInCirc'); } else { $(this).fadeOut('fast'); } } this.editorController.RENDER = thisClass.RENDER; if (thisClass.REVISION == true) { thisClass.VIEWER = true; } if (thisClass.RENDER == true) { thisClass.VIEWER = true; thisClass.RENDER = true; } this.componentList.constructor(); this.editorController.constructor(); this.registerHandlebarHelpers(); if (thisClass.PUBLIC) { thisClass.viewPublicState(); } if (thisClass.RENDER) { thisClass.viewState('render'); } else if (thisClass.VIEWER) { thisClass.viewState('revision'); } else { thisClass.viewState('editor'); }thisClass.changeUIByPermission(); mf_main.interfaceResize(); $('.close').on('click', thisClass.closeHandler); $(document).on('click', '.modal-backdrop', thisClass.closeHandler); $('html').on('click', (event) => { thisClass.closePopUpHandler(event); $('#mfZoomPopup').hide(); }); $('.mfImgLink').on('mouseover', thisClass.imgLinkOver); $('.mfImgLink').on('mouseout', thisClass.imgLinkOut); thisClass.editorController.openEditor(thisClass.projectID); $('[data-toggle="tooltip"]').tooltip(); }; this.viewPublicState = function () { $('#mfProjectEditBtn').hide(); $('#mfPageSidebarPost').height(180); $('#mfPublicBox').show(); $('#mfPublicReplyBox').show(); }; this.viewState = function (state) { if (thisClass.PERMISSION == 'Reviewer' || thisClass.PUBLIC) { if (state == 'editor') { state = 'viewer'; } } if (state == 'revision') { document.title = 'MockFlow WireframePro - Revision Viewer'; this.editorController.VIEWER = true; this.editorController.EDITOR = false; $('#mfEditorHeader').hide(); $('#mfEditorCompTypes').hide(); $('#mfPageActionBar').hide(); $('#mfComponentSettings').hide(); this.editorController.resizeEditor(); } else if (state == 'render') { document.title = 'MockFlow WireframePro - Viewer'; thisClass.editorController.VIEWER = true; thisClass.editorController.EDITOR = false; thisClass.editorController.RENDER = false; $('#mfEditorBackBtn').hide(); $('#mfPageManagerArea').hide(); $('.mfShowSidebar').hide(); mf_main.editorController.showPreview(true); thisClass.interfaceResize(); } else if (state == 'viewer') { document.title = 'MockFlow WireframePro - Viewer'; thisClass.editorController.VIEWER = true; thisClass.editorController.EDITOR = false; $('#mfEditorBackBtn').hide(); mf_main.editorController.showPreview(true); thisClass.interfaceResize(); } else { this.shortcutsFlag = true; this.editorController.VIEWER = false; this.editorController.EDITOR = true; $('#mfViewerHeader').hide(); $('#mfEditorHeader').show(); this.editorController.showEditor(); this.editorController.resizeEditor(); this.editorController.startAutoSave(); } }; this.changeUIByPermission = function () { if (thisClass.PERMISSION == 'Reviewer' || thisClass.PUBLIC) { $('#mfProjectEditBtn').hide(); } }; this.imgLinkOver = function (e) { $(this).css('opacity', 0.5); }; this.imgLinkOut = function (e) { $(this).css('opacity', 1); }; this.addTemplateToCache = function (key, template) { this.cachedTemplates[key] = template; }; this.getTemplateFromCache = function (key) { return this.cachedTemplates[key]; }; this.closePopUpHandler = function (event) {}; this.closeHandler = function () { thisClass.closeDialog(); }; this.interfaceResize = function () { if (thisClass.editorController) { thisClass.editorController.resizeEditor(); }thisClass.closePopUpHandler(); }; this.registerHandlebarHelpers = function () {}; this.closeDialog = function () { $('.mfPopUp').hide(); $('.modal').modal('hide'); $('#mfCompCategoryDialog').hide(); }; } function receiveRTS(txt) { alert(txt); }jQuery.cachedScript = function (url, options) { options = $.extend(options || {}, { dataType: 'script', cache: true, url }); return jQuery.ajax(options); }; $.getMultiScripts = function (arr, path) { const _arr = $.map(arr, scr => $.cachedScript((path || '') + scr)); _arr.push($.Deferred((deferred) => { $(deferred.resolve); })); return $.when(..._arr); }; function imgOnLoad() {} function MF_EditorController() {
  this.SHOWGUIDELINES = true; this.selectedFontComp = null; this.lastOpenViewerContent = 'mfViewerNavPagesBtn'; this.cachedDBComponents = new Object(); this.grid = null; this.showLinks = true; this.showAnnotations = true; this.currentNavBarEditorShown = 'mfNavElementBtn'; this.ctop = 0; this.cleft = 0; this.loadedPages = new Array(); this.clicks = 0; this.clicktimer = null; this.clickDELAY = 200; this.editingComponent = false; this.editingComponentDiv = null; this.sidebarShow = true; this.EDITOR = true; this.VIEWER = false; this.RENDER = false; this.SCALE = 1; this.transformDragType = 'start'; this.rememberToggleSettings = new Object(); this.projectObj = null; this.movedObject = false; this.timer = null; this.shortcutsFlag = false; this.page = null; this.componentSelect = new Array(); this.selectorResize = null; this.selectorTransformStart = null; this.selectorTransformEnd = null; this.lastTextEditComp = null; this.hbox = null; this.wbox = null; this.movePagePosX = null; this.movePagePosY = null; this.oldPagePosX = null; this.oldPagePosY = null; this.pageDragging = false; this.pagePanning = false; this.viewerShortcuts = false; this.selectedComponent = null; this.mouseStartX = 0; this.mousestartY = 0; this.maxDx = 0; this.maxDy = 0; this.offsetMousex = 0; this.offsetMousey = 0; this.rotateOffset = 0; this.offsetYPos = 0; this.offsetXPos = 0; this.lastSetting = null; this.settingManualPlace = false; this.settingPosX = 0; this.settingPosY = 0; this.commentController = new MF_CommentController(); this.fontController = new MF_FontController(); this.pageController = new MF_PageController(); this.highlightViewerLinks = new Array(); this.isCtrl = false; this.isShift = false; this.isDrag = false; this.transformDrag = false; this.canSave = false; this.globalSelect = null; this.pageloaded = false; const thisClass = this; this.resized = false; this.selectorDragged = false; this.original = { top: 0, left: 0 }; this.mouseMoving = false; this.onGlobalSelect = false; this.lastOpenedMfPopUp = null; this.constructor = function () { $('#mfPageManagerArea').mouseover((e) => { if (!thisClass.EDITOR) { thisClass.viewerShortcuts = false; } }); $('#mfNavbarZoomBtn').on('click', thisClass.showZoomPopup); $('#mfZoomBarPlusBtn').on('click', mf_main.editorController.zoomPlus); $('#mfZoomBarMinusBtn').on('click', mf_main.editorController.zoomMinus); $('#mfZoomBar100Btn').on('click', mf_main.editorController.viewFullSize); $('#mfToggleLinkHighlight').click(thisClass.toggleLinkHighlighter); $('#mfToggleAnnotations').click(thisClass.toggleAnnotationsHandler); thisClass.commentController.constructor(); thisClass.fontController.constructor(); thisClass.pageController.constructor(); thisClass.initEditor(); thisClass.keyShortcutHandler(); $('.mftooltip').tooltip({ animation: false }); $('.mfNavBarButton').on('click', thisClass.openNavBar); $('.mfViewerNavBarButton').on('click', thisClass.openNavBar); $('#mfPageManagerArea').on('click', '#mfNavbarToggleBtn', thisClass.hideNavBar); $('.mfShowSidebar').on('click', thisClass.showNavBar); const sidebarTogg = MF_Utils.getParameterByName('sidebar'); if (sidebarTogg && sidebarTogg === 'off') { thisClass.hideNavBar(new Event('')); } }; this.showZoomPopup = function (e) {
    e.stopImmediatePropagation(); const lastOpenedPopUp = thisClass.lastOpenedMfPopUp; if (lastOpenedPopUp) { if (lastOpenedPopUp.attr('id') != $('#mfZoomPopup').attr('id')) { $(lastOpenedPopUp).hide(); } } if ($('#mfZoomPopup').css('display') == 'block') { $('#mfZoomPopup').hide(); return; } let x = e.clientX,
      y = e.clientY,
      width = $(e.target).width(); const positionX = (e.clientX - e.offsetX + $('#mfZoomPopup').width() - 80); const positionY = (e.clientY - e.offsetY - $('#mfZoomPopup').height() + 10); $('#mfZoomPopup').css({ top: positionY, left: positionX + 400 }); $('#mfZoomPopup').show(); $('#mfZoomPopup').animate({ left: `${positionX}px` }, 300, 'easeOutBack'); thisClass.lastOpenedMfPopUp = $('#mfZoomPopup');
  }; this.toggleLinkHighlighter = function (e) { const $this = $(this); if ($this.is(':checked')) { thisClass.showLinks = true; } else { thisClass.showLinks = false; }thisClass.showLinkHighlights(); }; this.toggleAnnotationsHandler = function (e) { const $this = $(this); if ($this.is(':checked')) { thisClass.showAnnotations = true; } else { thisClass.showAnnotations = false; }thisClass.toggleAnnotations(); }; this.openLink = function (e, gid) { if (thisClass.EDITOR) { return; }e.stopImmediatePropagation(); let compid = $(this).attr('id'); if (compid == null) { compid = gid; } let component = null; component = thisClass.getGroupById(compid); if (component == null) { component = thisClass.getComponentById(compid); } if (component) { if (component.linkObj != null) { if (component.linkObj.type == 'web') { window.open(component.linkObj.url, '_blank'); } else { const page = MF_PagePool.getPage(component.linkObj.url); if (page) { thisClass.viewPage(page); } } } } }; this.toggleAnnotations = function () { if (thisClass.page) { let show = false; if (thisClass.EDITOR) { show = true; } for (let k = 0; k < thisClass.loadedPages.length; k++) { const page = thisClass.loadedPages[k]; for (let i = 0; i < page.childComponents.size(); i++) { const component = page.childComponents.getItemAt(i); if (component.ANNOTATION) { if (thisClass.showAnnotations || show) { $(`#${component.eid}`).show(); } else { $(`#${component.eid}`).hide(); } } } } } }; this.toggleLinks = function () { if (thisClass.page) { thisClass.highlightViewerLinks = new Array(); let show = true; if (thisClass.EDITOR) { show = false; } for (let k = 0; k < thisClass.loadedPages.length; k++) { const page = thisClass.loadedPages[k]; for (let i = 0; i < page.childComponents.size(); i++) { const component = page.childComponents.getItemAt(i); if (component.selector && component.link != '') { if (show) { component.selector.setVisible(false); MF_ComponentSettingUtils.convert2LinkObj(component); thisClass.highlightViewerLinks.push(component.selector); $(`#${component.eid}`).on('click', thisClass.openLink); } else { component.selector.setVisible(true); $(`#${component.eid}`).off('click', thisClass.openLink); } } else if (component.selector) { if (show) { component.selector.setVisible(false); } else { component.selector.setVisible(true); } if (component.ALLOW_MULTILINK && component.pageSetLink) { if (show) { thisClass.highlightViewerLinks.push(component.selector); component.render(false); MF_ComponentSettingUtils.assignMultiLink(component); } else { $(`.${component.eid}_itemCls`).off('click'); } } } } for (const n in page.groupManager.groupSelectors) { const gselector = page.groupManager.groupSelectors[n]; if (gselector) { const linkObj = page.groupManager.linkedGroups[n]; let linkpresent = false; if (linkObj && linkObj.link != '') { if (show) { linkpresent = true; gselector.setVisible(true); MF_ComponentSettingUtils.convert2LinkObj(linkObj); $(`#${gselector.id}`).css('pointer-events', 'auto'); thisClass.highlightViewerLinks.push(gselector); } else { gselector.setVisible(true); } } if (linkpresent == false) { if (show) { gselector.setVisible(false); } else { gselector.setVisible(true); } } } } } if (thisClass.VIEWER && thisClass.showLinks) { thisClass.showLinkHighlights(); } } }; this.preFetchPages = function () { if (mf_main.RENDER || mf_main.REVISION || thisClass.EDITOR) { return; }prefetchPageList = new Object(); for (let k = 0; k < thisClass.loadedPages.length; k++) { var page = thisClass.loadedPages[k]; for (let i = 0; i < page.childComponents.size(); i++) { const component = page.childComponents.getItemAt(i); if (component && component.selector && component.link != '' && component.link != null) { var linkarr = component.link.split(':--:'); if (linkarr && linkarr.length == 3) { if (linkarr[1] == 'page') { prefetchPageList[linkarr[2]] = true; } } } else if (component && component.selector && component.ALLOW_MULTILINK && component.pageSetLink && component.linkArray) { for (var key in component.linkArray) { const link = component.linkArray[key]; if (link != '' && link != null) { var linkarr = link.split(':--:'); if (linkarr && linkarr.length == 3) { if (linkarr[1] == 'page') { prefetchPageList[linkarr[2]] = true; } } } } } } } const masterpagesPrefetch = new Object(); for (var key in prefetchPageList) { thisClass.getAllPages(key, masterpagesPrefetch); } for (var key in masterpagesPrefetch) { prefetchPageList[key] = true; } for (var key in prefetchPageList) { var page = MF_PagePool.getPage(key); if (page && page.loaded == false && page.noDBLoad == false) { let pdataeval = ''; if (MFPAGEOBJARR[page.eid]) { pdataeval = MFPAGEOBJARR[page.eid]; } const pageDataObj = new MF_PageData(); pageDataObj.eid = page.eid; pageDataObj.projectid = thisClass.projectObj.eid; pageDataObj.name = page.pageName; pageDataObj.data = pdataeval; page.pagedata = pageDataObj; page.noDBLoad = true; const jData2 = $(page.pagedata.data); page.e2xml.settingsXML = jData2; $(page.e2xml.settingsXML).find('children').each(function () { const jData = $('<div/>').append($(this).clone()); jData.find('component').each(function () { mf_main.componentList.invokeComponent($(this).attr('type'), 'noload'); }); }); } } }; this.getAllPages = function (pageid, masterpagesPrefetch) { const page = MF_PagePool.getPage(pageid); if (page && page.masterPage != '') { const masterPage = MF_PagePool.getPage(page.masterPage); if (masterPage) { masterpagesPrefetch[masterPage.eid] = true; thisClass.getAllPages(masterPage.eid, masterpagesPrefetch); } } }; this.showLinkHighlights = function (noauto) { if (thisClass.VIEWER == false) { return; } if (mf_main.RENDER) { return; } if (noauto != true && thisClass.showLinks == false) { return; } for (let b = 0; b < thisClass.highlightViewerLinks.length; b++) { const selector = thisClass.highlightViewerLinks[b]; if (selector) { selector.setVisible(true); $(`#${selector.id}`).css('background-color', 'rgba(255,204,51,0.5)'); } } if (noauto) {} else { var myVar = setInterval(() => { thisClass.hideLinkHighlights(); clearInterval(myVar); }, 1000); } }; this.hideLinkHighlights = function () { for (let b = 0; b < thisClass.highlightViewerLinks.length; b++) { const selector = thisClass.highlightViewerLinks[b]; if (selector) { if (selector.GROUP == false) { selector.setVisible(false); }$(`#${selector.id}`).css('background-color', 'rgba(0,0,0,0)'); } } }; this.showPreview = function (noload) { thisClass.VIEWER = true; thisClass.EDITOR = false; thisClass.clearSelection(); thisClass.disableShortcuts(); mf_main.closeDialog(); if (thisClass.pageController.treeview) {}$('#mfEditorHolder').addClass('mfCursorHighlight'); $('#mfViewerHeader').show(); $('.mfViewerUICls').show(); $('.mfNavBarButton').hide(); $('.mfViewerNavBarButton').show(); $('.mfNavBarContentHolderCls').hide(); $('.mfViewerNavBarContentHolderCls').show(); $('#mfToggleLinkHighlight').attr('checked', thisClass.showLinks); thisClass.toggleVisibleTopBar(); thisClass.openNavBarContent(thisClass.lastOpenViewerContent); thisClass.toggleLinks(); thisClass.toggleAnnotations(); if (noload == true) {} else if (thisClass.page) { thisClass.viewPage(thisClass.page, true); }thisClass.showCalloutTooltips(); thisClass.hideHotSpots(); if (mf_main.RENDER == false) { MF_Utils.display_ActionIndicator('Press SHIFT key to show link highlights'); } }; this.hideCalloutTooltips = function () { $('.mfCalloutCls').tooltip('destroy'); $('.mfCalloutCls').attr('data-toggle', ''); }; this.showCalloutTooltips = function () { $('.mfCalloutCls').attr('data-toggle', 'tooltip'); $('[data-toggle="tooltip"]').tooltip({ container: 'body' }); }; this.hideHotSpots = function () { $('.mfHotspotCmpCls').css('opacity', 0); }; this.showHotSpots = function () { $('.mfHotspotCmpCls').css('opacity', 1); }; this.hideNavBar = function (ev) { $('#mfPageManagerArea').fadeOut('fast', (el) => { $('.mfShowSidebar').fadeIn('fast'); thisClass.sidebarShow = false; thisClass.formAddressHash(); thisClass.resizeEditor(); }); }; this.showNavBar = function (ev) { $('.mfShowSidebar').fadeOut('fast', (el) => { $('#mfPageManagerArea').fadeIn('fast', (el) => { thisClass.sidebarShow = true; thisClass.resizeEditor(); }); }); }; this.formAddressHash = function () { if (mf_main.editorController.page) { let urlhash = `/page/${mf_main.editorController.page.eid}`; if (thisClass.sidebarShow == false) { urlhash += '/sidebar/off'; }window.location.hash = urlhash; } }; this.resetNavBar = function (e) { $('.mfNavBarContentHolderCls').hide(); $('.mfNavBarButton').css('color', '#666'); }; this.resetViewNavBar = function (e) { $('.mfViewerNavBarContentHolderCls').hide(); $('.mfViewerNavBarButton').css('color', '#666'); }; this.openNavBar = function (e) { thisClass.openNavBarContent($(this).attr('id')); }; this.openNavBarContent = function (nid) { thisClass.resetNavBar(); thisClass.resetViewNavBar(); $(`#${nid}`).css('color', '#2286FB'); if (nid == 'mfNavPagesBtn') { thisClass.currentNavBarEditorShown = 'mfNavPagesBtn'; $('#mfContentPages').show(); thisClass.pageController.resize(); } if (nid == 'mfViewerNavToggleBtn') { thisClass.lastOpenViewerContent = 'mfViewerNavToggleBtn'; $('#mfViewerContentToggle').show(); } if (nid == 'mfViewerNavPagesBtn') { thisClass.lastOpenViewerContent = 'mfViewerNavPagesBtn'; $('#mfContentPages').show(); thisClass.pageController.resize(); }thisClass.resizeEditor(); }; this.openViewerNavBar = function (e) { $('.mfViewerNavBarContentHolderCls').hide(); $('.mfViewerNavBarButton').css('color', '#666'); $(this).css('color', '#2286FB'); }; this.pageScrollHandler = function (e) { $('.dropdowncomp_content').hide(); }; this.viewFullSize = function (e) { if (e) { e.stopImmediatePropagation(); }thisClass.SCALE = 1; thisClass.zoomPage(); }; this.zoomPage = function () { if (!thisClass.RENDER && mf_main.editorController.page) { $('#mfEditorHolder').scrollLeft(0); $('#mfEditorHolder').scrollTop(0); $('#mfContainerPage').css('visibility', 'none'); $('#mfContainerPage').css('transform-origin', 'top left'); $('#mfContainerPage').css('-webkit-transform-origin', 'top left'); thisClass.clearSelection(); $('#mfContainerPage').css('-webkit-transform', `scale(${thisClass.SCALE},${thisClass.SCALE})`); $('#mfContainerPage').css('transform', `scale(${thisClass.SCALE},${thisClass.SCALE})`); $('#mfContainerPage').css('-ms-transform', `scale(${thisClass.SCALE},${thisClass.SCALE})`); $('#mfContainerPage').css('visibility', 'visible'); mf_main.interfaceResize(); thisClass.ctop = $('#mfContainerPage').position().top; thisClass.cleft = $('#mfContainerPage').position().left; } }; this.loadProject = function (projectObj) { if (projectObj == null) { alert('Permission Denied'); return; } thisClass.loadProjectXML(); }; this.openEditor = function (projectid) { MF_PagePool.clean(); thisClass.projectObj = new MF_Project(); thisClass.projectObj.title = 'Wireframe'; thisClass.projectObj.data = mfprojectdata; thisClass.projectObj.company = MFCOMPANYID; thisClass.projectObj.id = MFPROJECTID; thisClass.loadProject(thisClass.projectObj); }; this.loadProjectXML = function () { if (thisClass.projectObj.data != null) { thisClass.projectObj.data = jQuery.trim(thisClass.projectObj.data); $(thisClass.projectObj.data).find("component[type='Page']").each(function () { const outerHtml = $('<div/>').append($(this).clone()).html(); const jData = $(outerHtml); const page = new MF_Page(); page.eid = jData.attr('eid'); page.pageName = jData.attr('pageName'); page.createPageData(); if (jData.attr('parentPage') != null) { page.parentPage = jData.attr('parentPage'); } else { page.parentPage = ''; } if (jData.attr('masterPage') != null) { page.masterPage = jData.attr('masterPage'); } else { page.masterPage = ''; } if (jData.attr('navHide') == 'true') { page.navHide = true; } if (jData.attr('folder') == 'true') { page.folder = true; }page.e2xml.applySettings(); MF_PagePool.addPage(page); }); if (MF_PagePool.getPages().size() == 0) { MF_PagePool.addNewPage(); }thisClass.pageController.listPages(); if (mf_main.pageID != null) { const page = MF_PagePool.getPage(mf_main.pageID); if (page == null) { thisClass.viewPage(thisClass.get1stPage()); } else { thisClass.viewPage(page); } } else { thisClass.viewPage(thisClass.get1stPage()); } }thisClass.canSave = true; mf_main.interfaceResize(); thisClass.editorEvents(); }; this.changeRotationWidth = function (component, newWidth) { const ang = component.eangle * 3.14 / 180; const calcX = newWidth - component.selector.width + (component.selector.delta * 2); const transX = calcX / 2; let newX = 0; let newY = 0; newX = -transX + transX * Math.cos(ang); newY = transX * Math.sin(ang); component.selector.y = component.selector.y + newY; component.selector.width = component.selector.width + calcX; component.selector.height = component.selector.height; component.selector.render(false); component.selector.setSize(); thisClass.addSelectorResize(component.selector); }; this.changeRotationHeight = function (component, newHeight) { const ang = component.eangle * 3.14 / 180; const calcY = newHeight - component.selector.height + (component.selector.delta * 2); const transY = calcY / 2; let newX = 0; let newY = 0; newX = -transY * Math.sin(ang); newY = -transY + transY * Math.cos(ang); component.selector.x = component.selector.x + newX; component.selector.y = component.selector.y + newY; component.selector.width = component.selector.width; component.selector.height = component.selector.height + calcY; component.selector.render(false); component.selector.setSize(); thisClass.addSelectorResize(component.selector); }; this.toggleVisibleTopBar = function () { if ($('#mfUnSavedBtn').css('display') == 'block' || $('#mfGroupEditingNotifier').css('display') == 'block') { $('#mfVisibleTopBar').show(); $('#mfVisibleTopBar').css({ position: 'absolute', top: 0, left: $(window).width() - $('#mfVisibleTopBar').width() - 50 }); } else { $('#mfVisibleTopBar').hide(); } }; this.resizeEditor = function () { let rtcLeft = 320; if (thisClass.sidebarShow == false) { rtcLeft = 50; }$('#mfNavBarContent').height($(window).height()); $('#mfEditorHolder').height($(window).height()); if ($('#mfPageManagerArea').css('display') == 'block') { $('#mfPageArea').width($(window).width() - $('#mfPageManagerArea').width() - 2); } else { $('#mfPageArea').width($(window).width() - 60); }$('#mfPageManagerArea').height($(window).height()); if ($('#mfContentPages').css('display') == 'block') { $('#mfContentPages').height($('#mfNavBarContent').height() - 20); $('#mfPageList').height($('#mfContentPages').height() - $('#mfPageActionBar').height() - $('#mfPageToggleSettings').height() - 50); }thisClass.pageController.resize(); thisClass.cleft = $('#mfContainerPage').position().left; if (mf_main.RENDER || mf_main.REVISION) { $('#mfPageLoader').css({ position: 'absolute', top: 0, left: 0 }); $('#mfPageLoader').width($(window).width() - rtcLeft); $('#mfEditorHolder').css('background', '#ffffff'); $('#mfPageLoader').height($('#mfPageManagerArea').height()); $('#mfPageLoaderImg').css({ position: 'absolute', top: (($('#mfPageLoader').height() / 2) - ($('#mfPageLoaderImg').height() / 2)), left: (($('#mfPageLoader').width() / 2) - ($('#mfPageLoaderImg').height() / 2)) + 150 }); } else { $('#mfPageLoader').css({ position: 'absolute', top: 0, left: rtcLeft }); $('#mfPageLoader').width($(window).width() - rtcLeft); $('#mfPageLoader').height($('#mfPageManagerArea').height()); $('#mfPageLoaderImg').css({ position: 'absolute', top: (($('#mfPageLoader').height() / 2) - ($('#mfPageLoaderImg').height() / 2)), left: (($('#mfPageLoader').width() / 2) - ($('#mfPageLoaderImg').height() / 2)) }); }$('#mfFontSelectionPopUp,#mfIconSelectionPopUp').hide(); $('#mfNavBar').height($(window).height()); thisClass.resizePage(); }; this.enableShortcuts = function () { if (thisClass.EDITOR) { thisClass.shortcutsFlag = true; } else { thisClass.viewerShortcuts = true; } }; this.disableShortcuts = function () { thisClass.shortcutsFlag = false; thisClass.viewerShortcuts = false; }; this.saveHandler = function () { thisClass.saveProject(false); }; this.keyShortcutHandler = function () { $(document).bind('keyup', (evt) => { if (thisClass.VIEWER) { if (evt.shiftKey == false) { thisClass.hideLinkHighlights(); } } if (evt.keyCode == '27') { return false; } if (evt.keyCode == '32') { $('#mfPanningDiv').hide(); thisClass.pagePanning = false; $('#mfEditorHolder').css('cursor', ''); return false; } }); $(document).bind('keydown', (evt) => { if (evt.keyCode == '27') { mf_main.closeDialog(); $('.mfPopUp').hide(); return false; } if (thisClass.EDITOR && thisClass.shortcutsFlag) { if (evt.keyCode == '32') { thisClass.pagePanning = true; $('#mfPanningDiv').show(); $('#mfEditorHolder').css('cursor', 'pointer'); if (thisClass.page) { $('#mfPanningDiv').width($(`#mfPage${mf_main.editorController.page.eid}`).width()); $('#mfPanningDiv').height($(`#mfPage${mf_main.editorController.page.eid}`).height()); } return false; } } if (thisClass.VIEWER && thisClass.viewerShortcuts) { if (evt.keyCode == '32') { thisClass.pagePanning = true; $('#mfPanningDiv').show(); $('#mfEditorHolder').css('cursor', 'pointer'); if (thisClass.page) { $('#mfPanningDiv').width($(`#mfPage${mf_main.editorController.page.eid}`).width()); $('#mfPanningDiv').height($(`#mfPage${mf_main.editorController.page.eid}`).height()); } return false; } }thisClass.isShift = evt.shiftKey; thisClass.isCtrl = evt.ctrlKey; if (thisClass.isCtrl == false) { thisClass.isCtrl = evt.metaKey; } if (thisClass.isCtrl && evt.keyCode == '187') { thisClass.zoomPlus(); return false; } if (thisClass.isCtrl && evt.keyCode == '189') { thisClass.zoomMinus(); return false; } if (thisClass.VIEWER) { if (thisClass.isShift) { thisClass.showLinkHighlights(true); } } }); }; this.zoomPlus = function (e) { if (e) { e.stopImmediatePropagation(); } if (thisClass.SCALE < 3) { thisClass.SCALE += 0.1; thisClass.zoomPage(); $('#mfAnnotateArrow').hide(); } }; this.zoomMinus = function (e) { if (e) { e.stopImmediatePropagation(); } if (thisClass.SCALE > 0.1) { thisClass.SCALE -= 0.1; thisClass.zoomPage(); $('#mfAnnotateArrow').hide(); } }; this.initEditor = function () { thisClass.selectorResize = new MF_SelectorResize(); thisClass.blankProject(); }; this.selectHighlight = function (obj) { if (thisClass.globalSelect != null) { thisClass.removeGlobalSelect(); }obj.Select(); let add = true; for (let i = 0; i < thisClass.componentSelect.length; i++) { const select = thisClass.componentSelect[i]; if (select == obj) { add = false; break; } } if (add) { thisClass.componentSelect[thisClass.componentSelect.length] = obj; } }; this.showGlobalSelect = function () { if (thisClass.globalselect) { $(`#${thisClass.globalselect.id}`).css('pointer-events', 'auto'); $(`#${thisClass.globalselect.id}`).css('opacity', 1); } if (thisClass.selectorResize) { $(`#${thisClass.selectorResize.id}`).css('pointer-events', 'auto'); } }; this.hideGlobalSelect = function () { if (thisClass.globalselect) { $(`#${thisClass.globalselect.id}`).css('pointer-events', 'none'); $(`#${thisClass.globalselect.id}`).css('opacity', 0); } if (thisClass.selectorResize) { $(`#${thisClass.selectorResize.id}`).css('pointer-events', 'none'); } }; this.addSelectorResize = function (selector) { if (thisClass.selectorResize) { $(`#${thisClass.selectorResize.id}`).remove(); } if (selector == null) { return; } if (selector.component && selector.component == thisClass.lastTextEditComp) { return; }thisClass.selectorResize = new MF_SelectorResize(); thisClass.selectorResize.x = selector.x; thisClass.selectorResize.y = selector.y; thisClass.selectorResize.width = selector.width; thisClass.selectorResize.height = selector.height; thisClass.selectorResize.angle = selector.angle; thisClass.selectorResize.selector = selector; thisClass.selectorResize.render(); $(`#${thisClass.selectorResize.id}`).css('z-index', thisClass.page.stackOrder.size() + 20); $(`#${thisClass.selectorResize.id}_holder`).css('pointer-events', 'none'); $(`#${thisClass.selectorResize.id}`).css('pointer-events', 'none'); if (selector == thisClass.globalselect) { if (thisClass.isShift) { thisClass.hideGlobalSelect(); } else { thisClass.showGlobalSelect(); } }thisClass.selectorResize.setLocking(selector.locked); $(`#${thisClass.selectorResize.id}`).click((event) => { if (thisClass.RENDER || thisClass.VIEWER) {} }); $(`#${thisClass.selectorResize.id}`).mousedown((event) => { if (thisClass.RENDER || thisClass.VIEWER) {} }); $(`#${thisClass.selectorResize.id}_rotatebtn`).click((event) => { event.stopPropagation(); }); $(`#${thisClass.selectorResize.id}_rotatebtn`).mousedown((event) => { event.stopPropagation(); }); }; this.clearSelection = function () {}; thisClass.noSettingsClear = false; this.pageEvents = function () { $(`#mfPage${mf_main.editorController.page.eid}`).mouseup((e) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); $(`#mfPage${mf_main.editorController.page.eid}`).click((e) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); $(`#mfPage${mf_main.editorController.page.eid}`).mousemove((e) => { if (!thisClass.EDITOR) { thisClass.viewerShortcuts = true; } if (thisClass.VIEWER || thisClass.RENDER) {} }); $(`#mfPage${mf_main.editorController.page.eid}`).mousedown((e) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); }; this.editorEvents = function () { $('#mfPanningDiv').mousedown((event) => { event.stopImmediatePropagation(); if (thisClass.pagePanning) { thisClass.oldPagePosX = event.pageX; thisClass.oldPagePosY = event.pageY; thisClass.pageDragging = true; } }); $('#mfPanningDiv').mousemove((event) => { event.stopImmediatePropagation(); if (thisClass.pagePanning) { thisClass.movePagePosX = event.pageX; thisClass.movePagePosY = event.pageY; if (thisClass.pageDragging) { $('#mfEditorHolder').scrollTop($('#mfEditorHolder').scrollTop() + (thisClass.oldPagePosY - thisClass.movePagePosY)); $('#mfEditorHolder').scrollLeft($('#mfEditorHolder').scrollLeft() + (thisClass.oldPagePosX - thisClass.movePagePosX)); thisClass.oldPagePosX = thisClass.movePagePosX; thisClass.oldPagePosY = thisClass.movePagePosY; } } }); $('#mfPanningDiv').mouseup((event) => { event.stopImmediatePropagation(); thisClass.pageDragging = false; if (thisClass.pagePanning) {} }); $('#mfEditorHolder').click((event) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); $('#mfEditorHolder').mousedown((event) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); $('#mfEditorHolder').mousemove((event) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); $('#mfEditorHolder').mouseup((event) => { if (thisClass.VIEWER || thisClass.RENDER) {} }); }; this.getMouse = function (e, page) {
    let element = page,
      offsetX = 0,
      offsetY = 0; if (element.offsetParent) { do { offsetX += element.offsetLeft; offsetY += element.offsetTop; } while ((element = element.offsetParent)); }mx = (e.pageX - offsetX); my = (e.pageY - offsetY); const scrollTop = document.getElementById('mfEditorHolder').scrollTop; const scrollLeft = document.getElementById('mfEditorHolder').scrollLeft; mx += scrollLeft; my += scrollTop; const obj = new Object(); obj.mx = mx; obj.my = my; return obj;
  }; this.removeGlobalSelect = function () { if (thisClass.globalselect != null) { thisClass.globalselect.removeSelectionHighlights(); $(`#${thisClass.globalselect.id}`).remove(); thisClass.globalselect = null; } }; this.resetSelector = function (obj) { const selector = obj.selector; if (selector != null) { thisClass.resetSelectorSize(); thisClass.clearSelection(); if (obj.NAME != 'Page') { thisClass.selectHighlight(selector); } } }; this.resetSelectorSize = function (obj) { const selector = obj.selector; if (selector != null) { selector.x = obj.x - selector.delta; selector.y = obj.y - selector.delta; selector.width = obj.width + (selector.delta * 2); selector.height = obj.height + (selector.delta * 2); selector.angle = obj.eangle; } }; this.completeNewComponentLoad = function (component) { if (component.NAME == 'MF_ImageComp') { if (component.imageID != '') { const imgObj = thisClass.imageController.getImageByID('', component.imageID); if (imgObj) { component.width = imgObj.width; component.height = imgObj.height; } } } var szObject = new Object(); szObject.width = component.width; szObject.height = component.height; component.e2xml.addPropObject('esize', szObject, 'default'); if (component.NAME == 'MF_ImageComp') { var szObject = new Object(); szObject.width = component.width; szObject.height = component.height; component.originalEsize = szObject; }component.setDefaultSettings(); component.render(); const newselector = thisClass.addSelector(component); if (thisClass.currentGroupEdit != null) { component.GROUPID = thisClass.currentGroupEdit; thisClass.page.groupManager.addGroup(thisClass.currentGroupEdit, component); const gselect = thisClass.page.groupManager.groupSelectors[thisClass.currentGroupEdit]; if (gselect) { if (gselect.globalselects) { gselect.globalselects[newselector.id] = newselector; } } } if (component.TRANSFORM) { component.transformSelector(); } }; this.loadComponent = function (componentName, placement, eid, asset, currentXML, copyFlag, retainID) { if (retainID == undefined) { retainID = true; } if (eid == undefined) { eid = null; } if (asset == undefined) { asset = null; } if (currentXML == undefined) { currentXML = null; } if (copyFlag == undefined) { copyFlag = false; } const initialPoint = placement; const component = mf_main.componentList.invokeComponent(componentName); if (component) { component.x = initialPoint.x; component.y = initialPoint.y; if (eid && retainID) { if (MF_IDManager.IsIDGood(thisClass.page, eid)) { component.eid = eid; } else { MF_IDManager.generateComponentID(thisClass.page, component); } } else { MF_IDManager.generateComponentID(thisClass.page, component); } const posObject = new Object(); posObject.x = 0; posObject.y = 0; component.e2xml.addPropObject('ecoordinates', posObject, 'default'); if (copyFlag) { component.setVisible(false); component.e2xml.settingsXML = currentXML; component.e2xml.applySettings(); }component.render(); const selector = thisClass.addComponent(component, thisClass.page, copyFlag); if (thisClass.currentGroupEdit != null) { const gselect = thisClass.page.groupManager.groupSelectors[thisClass.currentGroupEdit]; if (gselect) { if (gselect.globalselects) { gselect.globalselects[selector.id] = selector; } } } return selector; } return null; }; this.addSelector = function (component, redo, noChange) { if (redo == null) { redo = false; } if (noChange == null) { noChange = false; } const selector = new MF_Selector(); selector.x = component.x - selector.delta; selector.y = component.y - selector.delta; selector.height = component.height + (selector.delta * 2); selector.width = component.width + (selector.delta * 2); selector.setLocking(component.transformLock); selector.component = component; selector.angle = component.eangle; component.selector = selector; selector.render(); if (component.TRANSFORM) { selector.setVisible(false); }mf_main.editorController.page.stackOrder.addItem(selector); $(`#${selector.id}`).css('z-index', mf_main.editorController.page.stackOrder.size()); mf_main.editorController.page.addSelector(selector); if (!component.TRANSFORM) { thisClass.selectorEvents(selector); if (selector.locked) { selector.setLocking(component.transformLock, true); } } return selector; }; this.blankProject = function () { thisClass.addNewPage(); }; this.guidGenerator = function () { const S4 = function () { return (((1 + Math.random()) * 65536) | 0).toString(16).substring(1); }; return `D${S4() + S4() + S4() + S4() + S4() + S4() + S4() + S4()}`; }; this.addNewPage = function () { thisClass.page = new MF_Page(); thisClass.page.eid = thisClass.guidGenerator(); thisClass.page.createPageData(); thisClass.page.e2xml.applySettings(); }; this.removeComponent = function (component) { $(`#${component.eid}`).remove(); thisClass.page.removeComponent(component.eid); component = null; }; this.resizePage = function () { try { if (thisClass.page && thisClass.page.loaded) { let highestWidth = 0; let highestHeight = 0; let lowestXPos = 0; let lowestYPos = 0; for (let k = 0; k < thisClass.loadedPages.length; k++) { var npage = thisClass.loadedPages[k]; if (npage == thisClass.page) { npage.calculateDimensions(); lowestXPos = npage.lowestX; lowestYPos = npage.lowestY; } if (npage.highestWidth > highestWidth) { highestWidth = npage.highestWidth; } if (npage.highestHeight > highestHeight) { highestHeight = npage.highestHeight; } } for (let m = 0; m < thisClass.loadedPages.length; m++) { var npage = thisClass.loadedPages[m]; npage.width = highestWidth + 100; npage.height = highestHeight + 100; if (npage.lowestX < lowestXPos) { lowestXPos = npage.lowestX; } if (npage.lowestY < lowestYPos) { lowestYPos = npage.lowestY; }npage.applySize(); } if (mf_main.RENDER) { $('#mfrenderbar').attr('data-width', thisClass.page.width + 50); $('#mfrenderbar').attr('data-height', thisClass.page.height + 50); $('#mfrenderbar').attr('data-x', lowestXPos); $('#mfrenderbar').attr('data-y', lowestYPos); } } } catch (e) {} }; this.get1stPage = function () { let page = null; for (let k = 0; k < MF_PagePool.getPages().size(); k++) { const pitem = MF_PagePool.getPages().getItemAt(k); if (pitem.folder == false) { page = pitem; if (!page.navHide) { break; } } } return page; }; this.cleanLoadedPages = function (page, force) { for (let k = 0; k < MF_PagePool.getPages().size(); k++) { const pitem = MF_PagePool.getPages().getItemAt(k); pitem.clean(); } }; this.isPageLoaded = function (pageid) { for (let k = 0; k < thisClass.loadedPages.length; k++) { const pitem = thisClass.loadedPages[k]; if (pitem.eid == pageid) { return true; } } return false; }; this.viewMasterPage = function (page) { if (page.masterPage != '') { const masterPage = MF_PagePool.getPage(page.masterPage); if (masterPage) { const alreadyLoaded = thisClass.isPageLoaded(page.masterPage); if (alreadyLoaded) { thisClass.loadPageComplete(); } else { thisClass.loadedPages.push(masterPage); if (masterPage.loaded) {} else { $('#mfContainerPage').append(`<div unselectable="on" id="mfPage${masterPage.eid}" style="top: 0px; left: 0px; background-color: rgba(255,255,255,0);   display: none; width: 595px; height: 841px; position: absolute; overflow: hidden; " ></div>`); }thisClass.loadPage(masterPage); } } else { thisClass.loadPageComplete(); } } else { thisClass.loadPageComplete(); } }; this.viewPage = function (page, force) { if (!thisClass.projectObj) { return; } if (page && page.folder) { return; } if (thisClass.page != page || force) { thisClass.loadedPages = new Array(); thisClass.loadedPages.push(page); if (thisClass.pageController.treeview) { const pageTreeItemData = thisClass.pageController.treeview.dataSource.get(page.eid); if (pageTreeItemData) { const pageTreeItem = thisClass.pageController.treeview.findByUid(pageTreeItemData.uid); if (pageTreeItem) { thisClass.pageController.treeview.select(pageTreeItem); } } }document.getElementById('mfEditorHolder').scrollTop = 0; document.getElementById('mfEditorHolder').scrollLeft = 0; if (page.master == false) { thisClass.pageController.selectPage(`mfPageItem${page.eid}`); }thisClass.clearSelection(); thisClass.cleanLoadedPages(); thisClass.page = page; thisClass.pageloaded = false; $('#mfPageLoader').show(); if (thisClass.page.loaded) { $(`#mfPage${mf_main.editorController.page.eid}`).show(); if (thisClass.grid) { thisClass.grid.setGrid(); } } else { thisClass.page.remove(); $('#mfContainerPage').append(`<div  id="mfPage${thisClass.page.eid}" style="top: 0px; left: 0px; background-color: rgba(255,255,255,0.9);   width: 595px; height: 841px; position: absolute; overflow: hidden; " ></div>`); }$(`#mfPage${thisClass.page.eid}`).css('background-color', 'rgba(255,255,255,1)'); if (!thisClass.page.assignedEvents) { thisClass.page.assignedEvents = true; thisClass.pageEvents(); } else {}$('#mfContainerPage').width($(`#mfPage${thisClass.page.eid}`).width()); $('#mfContainerPage').height($(`#mfPage${thisClass.page.eid}`).height()); thisClass.loadPage(page); } }; this.loadPageComplete = function () { if (thisClass.loadedPages && thisClass.loadedPages.length >= 1) { mf_main.editorController.page = thisClass.loadedPages[0]; }thisClass.resizePage(); $('#mfPageLoader').hide(); $('#mfContainerPage').show(); thisClass.pageloaded = true; mf_main.interfaceResize(); document.getElementById('mfEditorHolder').scrollTop = 0; document.getElementById('mfEditorHolder').scrollLeft = 0; mf_main.editorController.reStackComponents(); thisClass.zoomPage(); let count = 1; for (var k = thisClass.loadedPages.length - 1; k >= 0; k--) { const loadedPage = thisClass.loadedPages[k]; $(`#mfPage${loadedPage.eid}`).css('z-index', count); if (thisClass.page == loadedPage) { $(`#mfPage${loadedPage.eid}`).css('background-color', 'rgba(255,255,255,0)'); } else { $(`#mfPage${loadedPage.eid}`).css('background-color', 'rgba(255,255,255,0)'); }count++; } for (var k = 0; k < MF_PagePool.getPages().size(); k++) { const pitem = MF_PagePool.getPages().getItemAt(k); let pagePresentLoaded = false; for (let j = 0; j < thisClass.loadedPages.length; j++) { const pitemLoaded = thisClass.loadedPages[j]; if (pitemLoaded.eid == pitem.eid) { pagePresentLoaded = true; break; } } if (!pagePresentLoaded && pitem.loaded) { $(`#mfPage${pitem.eid}`).hide(); } } if (thisClass.VIEWER) { thisClass.showCalloutTooltips(); thisClass.hideHotSpots(); $('.mfNoteArrowCls').hide(); } else { thisClass.hideCalloutTooltips(); thisClass.showHotSpots(); thisClass.setMasterPage(); thisClass.setNavHide(); $('.mfNoteArrowCls').show(); }thisClass.toggleLinks(); thisClass.toggleAnnotations(); if (thisClass.VIEWER) { $('.mfWFCompCls').css('pointer-events', 'all'); } else { $('.mfWFCompCls').css('pointer-events', 'none'); }$('.mfWFNoteCls').css('pointer-events', 'all'); if (thisClass.grid) { thisClass.grid.setGrid(); }thisClass.preFetchPages(); }; this.finishLoadPage = function (page) { $(`#mfPage${page.eid}`).css('pointer-events', 'none'); $(`#mfPage${page.eid}`).show(); page.loaded = true; page.calculateDimensions(); thisClass.viewMasterPage(page); }; this.loadPageData = function (page) { const settingsData = page.e2xml.settingsXML; $(settingsData).find('children').each(function () { const jData = $('<div/>').append($(this).clone()); jData.find('component').each(function () { thisClass.getComponent($(this), page); }); }); page.groupManager.addAll(); for (let i = 0; i < page.childComponents.data.length; i++) { const comp = page.childComponents.data[i]; thisClass.addFont(comp); }thisClass.fontController.loadAllFonts(); page.groupManager.loadLockedGroups(settingsData); page.groupManager.loadLinkedGroups(settingsData); thisClass.finishLoadPage(page); }; this.addFont = function (comp) { if (comp && comp.USEFONT && comp.fontType != '' && comp.fontType != null) { if (comp.isGoogleFontUsed) { thisClass.fontController.addGoogleFontToArray(comp.fontType); } if (comp.fontType == 'sourcesanspro' || comp.fontType == 'SourceSans Pro' || comp.fontType == 'Source Sans Pro') { thisClass.fontController.usedFonts.sourcesanspro = { fontFamily: 'Source Sans Pro', isGoogleFont: true }; } else { thisClass.fontController.usedFonts[comp.fontType] = { fontFamily: comp.fontType, isGoogleFont: comp.isGoogleFontUsed }; } } }; this.loadPage = function (page) { if (!page.loaded) { mf_main.editorController.page = page; if (page.duplicated) { page.duplicated = false; thisClass.loadComponentSrc(page); } else if (page.noDBLoad) { page.noDBLoad = false; thisClass.loadComponentSrc(page); } else { let pdataeval = ''; if (MFPAGEOBJARR[page.eid]) { pdataeval = MFPAGEOBJARR[page.eid]; } const pageDataObj = new MF_PageData(); pageDataObj.eid = page.eid; pageDataObj.projectid = thisClass.projectObj.eid; pageDataObj.name = page.pageName; pageDataObj.data = pdataeval; page.pagedata = pageDataObj; page.loaded = true; const jData = $(page.pagedata.data); page.e2xml.settingsXML = jData; thisClass.loadComponentSrc(page); } } else { thisClass.finishLoadPage(page); } }; this.loadComponentSrc = function (page) { const componentPresent = new Object(); page.e2xml.settingsXML.find('component').each(function () { const ctype = $(this).attr('type'); if (mf_main.componentList.loadedComponentCode[ctype]) {} else { componentPresent[ctype] = true; } }); const componentsToBeLoaded = new Array(); for (const key in componentPresent) { componentsToBeLoaded.push(key); }mf_main.componentList.invokeComponentsSrc(componentsToBeLoaded, page); }; this.initComponent = function (componentXML, page) { const component = mf_main.componentList.invokeComponent(componentXML.attr('type')); if (component != null) { component.eid = `cmp${thisClass.guidGenerator()}`; if (component.TRANSFORM) { component.startX = parseFloat(componentXML.attr('startX')); component.startY = parseFloat(componentXML.attr('startY')); component.endX = parseFloat(componentXML.attr('endX')); component.endY = parseFloat(componentXML.attr('endY')); } else { component.x = parseFloat(componentXML.attr('x')); component.y = parseFloat(componentXML.attr('y')); if (!component.AUTOSIZE) { component.width = parseFloat(componentXML.attr('w')); component.height = parseFloat(componentXML.attr('h')); } }component.e2xml.settingsXML = componentXML; return component; } return null; }; this.getComponent = function (componentXML, page) { const component = thisClass.initComponent(componentXML, page); if (component) { thisClass.addComponent(component, page, true); } }; this.addComponent = function (component, page, undo) { if (undo == null) { undo = false; }page.addComponent(component); let groupID = String(component.e2xml.settingsXML.attr('groupID')); if (groupID == undefined || groupID == 'undefined' || groupID == null) { groupID = ''; } if (thisClass.currentGroupEdit) { groupID = thisClass.currentGroupEdit; } if (groupID != '') { component.GROUPID = groupID; page.groupManager.addGroup(groupID, component); }component.e2xml.applySettings(); component.render(); let newselector = null; if (undo) { newselector = thisClass.addSelector(component, null, true); } else { newselector = thisClass.addSelector(component); } return newselector; }; this.reStackComponents = function () { if (thisClass.page) { let count = 1; const groupSelects = new Object(); thisClass.page.stackOrder = new ArrayCollection(); for (let k = 0; k < thisClass.page.childComponents.size(); k++) { const obj = thisClass.page.childComponents.getItemAt(k); thisClass.page.stackOrder.addItem(obj); $(`#${obj.eid}`).css('z-index', count++); if (obj.selector) { const scount = count++; thisClass.page.stackOrder.addItem(obj.selector); $(`#${obj.selector.id}`).css('z-index', scount); obj.selector.zindex = scount; } if (obj.GROUPID != '' && obj.GROUPID != null) { groupSelects[obj.GROUPID] = count; } } for (const gid in groupSelects) { const gselect = thisClass.page.groupManager.groupSelectors[gid]; if (gselect) { const gcount = groupSelects[gid]; thisClass.page.stackOrder.addItemAt(gselect, gcount); $(`#${gselect.id}`).css('z-index', gcount); } } } }; this.unLockSelectorEvents = function (selector) { thisClass.selectorEvents(selector); }; this.lockSelectorEvents = function (selector) { $(`#${selector.id}`).unbind('mousedown'); $(`#${selector.id}`).unbind('dblclick'); $(`#${selector.id}`).unbind('dragstart'); $(`#${selector.id}`).unbind('drag'); $(`#${selector.id}`).unbind('dragend'); }; this.selectorEvents = function (selector) { $(`#${selector.id}`).click(function (event) { event.stopImmediatePropagation(); if (thisClass.RENDER || thisClass.VIEWER) { thisClass.openLink(event, $(this).attr('group-id')); } }); }; this.showPopUp = function (e, popup) {
    const lastOpenedPopUp = thisClass.lastOpenedMfPopUp; if (lastOpenedPopUp) { if (lastOpenedPopUp.attr('id') != $(popup).attr('id')) { $(lastOpenedPopUp).hide(); } }mf_main.editorController.disableShortcuts(); let x = e.clientX,
      y = e.clientY,
      width = $(e.target).width(); const positionX = 330 + 100; let positionY = (e.clientY - e.offsetY - $(popup).height()) + 170; if ((positionY + $(popup).height()) > $(window).height()) { positionY = $(window).height() - $(popup).height() - 50; } if (positionY < 0) { positionY = 10; } if ((positionY + $(popup).height()) > $(window).height()) { positionY = $(window).height() - $(popup).height() - 10; }$(popup).css({ top: positionY, left: positionX }); $(popup).animate({ left: `${330}px` }, 300, 'easeOutBack'); popup.toggle(); thisClass.lastOpenedMfPopUp = $(popup);
  }; this.getComponentById = function (compId) { let componentMatched = null; for (let k = 0; k < thisClass.loadedPages.length; k++) { const page = thisClass.loadedPages[k]; for (let i = 0; i < page.childComponents.data.length; i++) { const component = page.childComponents.data[i]; if (component.eid == compId) { componentMatched = component; return componentMatched; } } } return componentMatched; }; this.getGroupById = function (gid) { let componentMatched = null; for (let k = 0; k < thisClass.loadedPages.length; k++) { const page = thisClass.loadedPages[k]; const linkObj = page.groupManager.linkedGroups[gid]; if (linkObj) { componentMatched = linkObj; return componentMatched; } } return componentMatched; };
} function MF_PageController() { const thisClass = this; this.selectedPage = null; this.hbox = null; this.wbox = null; this.displayPageThumbnail = true; this.editPage = null; this.treeview = null; this.mastertreeview = null; this.gridChanged = true; this.mapChanged = true; this.sitemapController = null; this.scrollPos = 0; this.siteMapMode = 'expand'; this.constructor = function () { $('#mfPageSearchBox').on('textchange', thisClass.searchPageHandler); $('#mfToggleTreeBtn').on('click', thisClass.toggleSiteMapExpandHandler); }; this.toggleSiteMapExpandHandler = function (e) { if (thisClass.siteMapMode == 'expand') { thisClass.siteMapMode = 'collapse'; if (thisClass.treeview) { thisClass.treeview.collapse('.k-item'); } } else { thisClass.siteMapMode = 'expand'; if (thisClass.treeview) { thisClass.treeview.expand('.k-item'); } } }; this.searchPageHandler = function (e) { const searchval = $('#mfPageSearchBox').val().trim(); const query = searchval.toLowerCase(); const dataSource = $('#mfPageList').data('kendoTreeView').dataSource; thisClass.pagefilter(dataSource, query); }; this.pagefilter = function (dataSource, query) { let hasVisibleChildren = false; const data = dataSource instanceof kendo.data.HierarchicalDataSource && dataSource.data(); for (let i = 0; i < data.length; i++) { const item = data[i]; const text = item.text.toLowerCase(); const itemVisible = query === true || query === '' || text.indexOf(query) >= 0; const anyVisibleChildren = thisClass.pagefilter(item.children, itemVisible || query); hasVisibleChildren = hasVisibleChildren || anyVisibleChildren || itemVisible; item.hidden = !itemVisible && !anyVisibleChildren; } if (data) { dataSource.filter({ field: 'hidden', operator: 'neq', value: true }); } return hasVisibleChildren; }; this.resize = function () {}; this.listPages = function () { thisClass.scrollPos = $('#mfPageList').scrollTop(); MF_PagePool.mapPages(); const mapdata = MF_PagePool.getMap(); if (thisClass.treeview) { thisClass.treeview.destroy(); }$('#mfPageList').empty(); $('#mfPageList').kendoTreeView({ dragAndDrop: false, select: thisClass.pageItemClick, dataSource: mapdata }); thisClass.treeview = $('#mfPageList').data('kendoTreeView'); thisClass.treeview.expand('.k-item'); $('#mfPageList').scrollTop(thisClass.scrollPos); }; this.flattenTreeItems = function (data, parent, collection) { for (let i = 0; i < data.length; i++) { const item = data[i]; const page = thisClass.getPagebyID(`mfPageItem${item.id}`); if (page) { page.parentPage = parent; collection.addItem(page); }thisClass.flattenTreeItems(item.items, item.id, collection); } }; this.clearPageSelection = function () { $('.mfPageItemCls').css('background-color', 'transparent'); }; this.selectPage = function (pid) { thisClass.clearPageSelection(); for (let i = 0; i < MF_PagePool.getPages().size(); i++) { const item = MF_PagePool.getPages().getItemAt(i); if (`mfPageItem${item.eid}` == pid) { thisClass.selectedPage = item; $(`#mfPageItem${item.eid}`).css('background-color', '#2286FB'); break; } } }; this.getPagebyID = function (pid) { for (let i = 0; i < MF_PagePool.getPages().size(); i++) { const item = MF_PagePool.getPages().getItemAt(i); if (`mfPageItem${item.eid}` == pid) { return item; break; } } return null; }; this.pagefilter = function (dataSource, query) { let hasVisibleChildren = false; const data = dataSource instanceof kendo.data.HierarchicalDataSource && dataSource.data(); for (let i = 0; i < data.length; i++) { const item = data[i]; const text = item.text.toLowerCase(); const itemVisible = query === true || query === '' || text.indexOf(query) >= 0; const anyVisibleChildren = thisClass.pagefilter(item.children, itemVisible || query); hasVisibleChildren = hasVisibleChildren || anyVisibleChildren || itemVisible; item.hidden = !itemVisible && !anyVisibleChildren; } if (data) { dataSource.filter({ field: 'hidden', operator: 'neq', value: true }); } return hasVisibleChildren; }; this.pageItemClick = function (e) { const nodedata = $('#mfPageList').data('kendoTreeView').dataItem(e.node); if (nodedata && nodedata.imageUrl != 'images/editor/folder.png') { thisClass.selectPage(`mfPageItem${nodedata.id}`); let allow = true; if (mf_main.editorController.VIEWER) { if (thisClass.selectedPage && thisClass.selectedPage.navHide) { allow = false; MF_Utils.display_ActionIndicator('This page is hidden from view'); } } if (allow) { mf_main.editorController.viewPage(thisClass.selectedPage); if (mf_main.PUBLIC) { mf_main.editorController.formAddressHash(); } } } }; this.onPageDragStart = function (e) { if (mf_main.editorController.VIEWER) { e.preventDefault(); } }; } function MF_SelectorTransform() { const thisClass = this; this.x = 0; this.y = 0; this.selector = null; this.component = null; this.id = mf_main.editorController.guidGenerator(); this.delta = 5; this.type = 'start'; this.remove = function () { $(`#${this.id}`).remove(); }; this.render = function (redraw) { $(`#${this.id}`).remove(); let rectCode = ''; if (thisClass.type == 'start') { rectCode = `${rectCode}<div  id="${this.id}" class="transformhandle transformstarthandle mfResizeHandleBtn" style="-webkit-transform: translateZ(0); position:absolute;  top:${(thisClass.y).toString()}px; left:${(thisClass.x).toString()}px; " > `; rectCode += '</div>'; } else { rectCode = `${rectCode}<div  id="${this.id}" class="transformhandle transformendhandle mfResizeHandleBtn" style="-webkit-transform: translateZ(0); position:absolute;  top:${(thisClass.y).toString()}px; left:${(thisClass.x).toString()}px; " > `; rectCode += '</div>'; }$(`#mfPage${mf_main.editorController.page.eid}`).append(rectCode); $('.transformhandle').css('height', 8 / mf_main.editorController.SCALE); $('.transformhandle').css('width', 8 / mf_main.editorController.SCALE); $('.transformhandle').css('border-radius', `${(8 / mf_main.editorController.SCALE).toString()}px`); $('.transformhandle').css('-moz-border-radius', `${(8 / mf_main.editorController.SCALE).toString()}px`); $('.transformhandle').css('-webkit-border-radius', `${(8 / mf_main.editorController.SCALE).toString()}px`); $(`#${thisClass.id}`).css('top', thisClass.y - (8 / mf_main.editorController.SCALE) / 2 - 1); $(`#${thisClass.id}`).css('left', thisClass.x - (8 / mf_main.editorController.SCALE) / 2 - 1); if (thisClass.selector.locked) { $('.transformhandle').css('background-color', '#000000'); $('.transformhandle').css('border-color', '#ffffff'); } else { $('.transformhandle').css('background-color', '#ffcc33'); $('.transformhandle').css('border-color', '#000000'); } }; } function MF_SelectorResize() { const thisClass = this; this.x = 0; this.y = 0; this.angle = 0; this.width = 100; this.height = 100; this.prevX = 0; this.prevY = 0; this.prevAngle = 0; this.prevWidth = 100; this.prevHeight = 100; this.selector = null; this.id = mf_main.editorController.guidGenerator(); this.locked = false; this.delta = 0; this.setVisible = function (val) { this.visible = val; if ($(`#${this.id}`) != null) { if (this.visible) { $(`#${this.id}`).css('display', 'block'); if (thisClass.component) { if (thisClass.component.TRANSFORM) { $(`#${this.id}`).hide(); } } } else { $(`#${this.id}`).css('display', 'none'); } } }; this.getVisible = function () { return this.visible; }; this.setLocking = function (locked) { this.locked = locked; if (locked) { $('.handle').css('background-color', '#000'); $('.handle').css('border-color', '#fff'); } else { $('.handle').css('background-color', '#2286FB'); $('.handle').css('border-color', '#2196F3'); } }; this.resize = function (nx, ny, nwidth, nheight) { this.x = nx; this.y = ny; this.width = nwidth; this.height = nheight; const cwidth = this.width; const cheight = this.height; const ctop = this.y; const cleft = this.x; thisClass.refresh(); }; this.setRotationHandle = function () { if (thisClass.selector && thisClass.selector.GLOBAL_SELECT) { $(`#${this.id}_rotateline`).hide(); $(`#${this.id}_rotatebtn`).hide(); } else { $(`#${this.id}_rotatebtn`).show(); $(`#${this.id}_rotateline`).hide(); } }; this.refresh = function () { $(`#${this.id}`).css('top', this.y - (thisClass.delta * 3) + thisClass.delta); $(`#${this.id}`).css('left', this.x + thisClass.delta); $(`#${this.id}`).css('width', this.width - (thisClass.delta * 2)); $(`#${this.id}`).css('height', this.height + thisClass.delta); $(`#${this.id}_rotatebtn`).css('left', '10px'); $(`#${this.id}_holder`).css('top', (thisClass.delta * 3)); $(`#${this.id}_holder`).css('left', 0); $(`#${this.id}_holder`).css('width', this.width - (thisClass.delta * 2)); $(`#${this.id}_holder`).css('height', this.height - (thisClass.delta * 2)); MF_Utils.rotate(thisClass.id, thisClass.angle); thisClass.setRotationHandle(); thisClass.checkHandlesReq(); }; this.checkHandlesReq = function () { let hideHandles = false; if (thisClass.width < 16 || thisClass.height < 16) { if (thisClass.width < 16 && thisClass.height < 30) { hideHandles = true; } if (thisClass.height < 16 && thisClass.width < 30) { hideHandles = true; } } if (hideHandles) { $('.mfResizeHandleBtn').hide(); } else { $('.mfResizeHandleBtn').show(); } }; this.remove = function () { $(`#${this.id}`).remove(); }; this.render = function (redraw) { if (redraw == null) { redraw = true; } let rectCode = ''; const cwidth = this.width; const cheight = this.height; const ctop = this.y; const cleft = this.x; if (redraw) { $(`#${this.id}`).remove(); rectCode = `${rectCode}<div  unselectable="on"  id="${this.id}" class='drag' style=" -webkit-transform: translateZ(0); pointer-events: none; text-align: center; -webkit-user-select: none; -moz-user-select: none; user-select:none; position:absolute; width:${(cwidth + (thisClass.delta * 2)).toString()}px; height:${(cheight + (thisClass.delta * 2)).toString()}px; top:${(ctop - (thisClass.delta)).toString()}px; left:${(cleft - (thisClass.delta)).toString()}px; " > `; rectCode = `${rectCode}<div  id="${this.id}_holder"  style="-webkit-transform: translateZ(0); pointer-events: none; border: 1px solid #2286FB; -webkit-user-select: none; -moz-user-select: none; user-select:none; position:absolute; width:${(cwidth).toString()}px; height:${(cheight).toString()}px; top:${(thisClass.delta).toString()}px; left:${(thisClass.delta).toString()}px; " > `; rectCode += '</div>'; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle NE mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto; position: absolute;' class='handle NN mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle NW mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle WW mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle EE mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle SW mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle SS mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode += "<div style='-webkit-transform: translateZ(0); pointer-events: auto;' class='handle SE mfResizeHandleBtn mfRectResizeBtn'></div>"; rectCode = `${rectCode}<div id="${this.id}_rotatebtn" class="mfResizeHandleBtn rotatehandle" style="-webkit-transform: translateZ(0);  pointer-events: auto; position: absolute; top: -3px; left:100px;  ">`; rectCode += '</div>'; rectCode += '</div>'; $(`#mfPage${mf_main.editorController.page.eid}`).append(rectCode); } else { thisClass.refresh(); } if (thisClass.selector && thisClass.selector.GLOBAL_SELECT) { $(`#${this.id}`).css('pointer-events', 'auto'); } else { $(`#${this.id}`).css('pointer-events', 'none'); }$('.mfRectResizeBtn').css('height', 8 / mf_main.editorController.SCALE); $('.mfRectResizeBtn').css('width', 8 / mf_main.editorController.SCALE); $(`#${this.id}_rotatebtn`).css('height', 8 / mf_main.editorController.SCALE); $(`#${this.id}_rotatebtn`).css('width', 8 / mf_main.editorController.SCALE); $(`#${this.id}_rotatebtn`).css('left', `${(((cwidth) / 2) + (7 / mf_main.editorController.SCALE)).toString()}px`); $('.NN').css('left', `${(((cwidth) / 2) + (2 / mf_main.editorController.SCALE)).toString()}px`); $('.SS').css('left', `${(((cwidth) / 2) + (2 / mf_main.editorController.SCALE)).toString()}px`); $('.EE').css('top', `${(((cheight) / 2) - (4 / mf_main.editorController.SCALE)).toString()}px`); $('.WW').css('top', `${(((cheight) / 2) - (4 / mf_main.editorController.SCALE)).toString()}px`); if (thisClass.selector && thisClass.selector.component && thisClass.selector.component.TRANSFORM) { $(`#${this.id}`).hide(); } else if (thisClass.selector && thisClass.selector.component && thisClass.selector.component.AUTOSIZE) { $('.mfRectResizeBtn').hide(); } else { $('.mfRectResizeBtn').show(); }thisClass.checkHandlesReq(); MF_Utils.rotate(thisClass.id, thisClass.angle); thisClass.setRotationHandle(); }; } function MF_Selector() { const thisClass = this; this.UNEDIT = false; this.x = 0; this.y = 0; this.width = 100; this.height = 100; this.angle = 0; this.component = null; this.id = mf_main.editorController.guidGenerator(); this.locked = false; this.GROUP = false; this.GROUPID = ''; this.GLOBAL_SELECT = false; this.currentState = 'select'; this.globalselects = new Object(); this.balpha = 1; this.visible = true; this.origX = 0; this.origY = 0; this.origW = 0; this.origH = 0; this.POS = 0; this.mouseEnabled = true; this.delta = 0; this.zindex = 0; this.setLocking = function (locked, force) { let change = false; if (force == undefined) { force = false; } if (this.locked != locked) { change = true; } if (force) { change = true; } this.locked = locked; if (locked) { if (change) { mf_main.editorController.lockSelectorEvents(thisClass); } } else if (change) { mf_main.editorController.unLockSelectorEvents(thisClass); } }; this.toggleMouseAction = function (val) { if (val) { this.mouseEnabled = true; $(`#${thisClass.id}`).css('pointer-events', 'none'); } else { this.mouseEnabled = false; $(`#${thisClass.id}`).css('pointer-events', 'auto'); } }; this.removeSelectionHighlights = function (val) { for (const selectid in this.globalselects) { const select = this.globalselects[selectid]; select.setBalpha(0); } }; this.transform = function (comp) { thisClass.x = comp.x - thisClass.delta; thisClass.y = comp.y - thisClass.delta; thisClass.width = comp.width + (thisClass.delta * 2); thisClass.height = comp.height + (thisClass.delta * 2); thisClass.render(false); }; this.getGlobalSelectsArray = function () { const arr = new Array(); for (const selectid in this.globalselects) { const select = this.globalselects[selectid]; arr[arr.length] = select; } return arr; }; this.setSize = function (force, undo) { if (force == null) { force = false; } if (undo == null) { undo = true; } this.width = parseInt(this.width); this.height = parseInt(this.height); try { const undoarr = new Array(); if (this.GLOBAL_SELECT) { const sw = (this.width - (thisClass.delta * 2)) / (this.origW - (thisClass.delta * 2)); const sh = (this.height - (thisClass.delta * 2)) / (this.origH - (thisClass.delta * 2)); for (const selectid in this.globalselects) { const select = this.globalselects[selectid]; let nosize = false; if (select.component && select.component.LOCK_SIZE) { nosize = true; } const nwidth = (select.width - (thisClass.delta * 2)) * sw - 10; const nheight = (select.height - (thisClass.delta * 2)) * sh - 10; select.origW = select.width; select.origH = select.height; select.origX = select.x; select.origY = select.y; select.y = ((select.y - thisClass.origY) * sh) + thisClass.y + 10; select.x = ((select.x - thisClass.origX) * sw) + thisClass.x + 10; if (!nosize) { if (select.component) { if (!select.component.VRESIZE) { select.width = nwidth + (thisClass.delta * 2); } if (!select.component.HRESIZE) { select.height = nheight + (thisClass.delta * 2); } } else { select.width = nwidth + (thisClass.delta * 2); select.height = nheight + (thisClass.delta * 2); } } if (select.GROUP) { const globarr = select.setSize(force, false); for (let k = 0; k < globarr.length; k++) { undoarr.push(globarr[k]); }select.origW = select.width; select.origH = select.height; select.origX = select.x; select.origY = select.y; } else { if (select.component) { if (!select.component.AUTOSIZE) { select.component.height = select.height - (thisClass.delta * 2); select.component.width = select.width - (thisClass.delta * 2); } if (select.component.TRANSFORM) { select.component.x = select.x + select.delta; select.component.y = select.y + select.delta; select.component.computePoints(); } }select.setCoordinate(false, false, false); if (!nosize) { select.setSize(force, false); } } } this.origW = this.width; this.origH = this.height; this.origX = this.x; this.origY = this.y; mf_main.editorController.addSelectorResize(this); } else if (!this.component.LOCK_SIZE || force) { if (!this.component.AUTOSIZE) { this.component.height = this.height - (thisClass.delta * 2); this.component.width = this.width - (thisClass.delta * 2); } this.component.x = this.x + thisClass.delta; this.component.y = this.y + thisClass.delta; const sizeUI = new Object(); sizeUI.height = this.component.height; sizeUI.width = this.component.width; if (this.component.prevEsize != null) { this.component.esize = this.component.prevEsize; } if (undo) { this.component.e2xml.addPropObject('esize', sizeUI); } else { this.component.e2xml.addPropObject('esize', sizeUI, 'default'); } this.setCoordinate(false, false, false); this.render(false); if (this.component) { this.component.render(false); } }MF_Utils.rotate(thisClass.id, thisClass.angle); return undoarr; } catch (err) {} return null; }; this.setCoordinate = function (undo, resizePage, render) { if (undo == null) { undo = true; } if (resizePage == null) { resizePage = true; } if (render == null) { render = true; } if (this.GROUP) { mf_main.editorController.rePositionComponents(this); } else if (!this.component.LOCK_POSITION) { if (this.component.TRANSFORM) { var posObject = new Object(); posObject.startX = this.component.startX; posObject.startY = this.component.startY; posObject.endX = this.component.endX; posObject.endY = this.component.endY; if (this.component.prevEcoordinates != null) { this.component.ecoordinates = this.component.prevEcoordinates; } if (undo) { this.component.e2xml.addPropObject('ecoordinates', posObject); } else { this.component.e2xml.addPropObject('ecoordinates', posObject, 'default'); } if (render) { this.component.render(false); } } else { this.component.x = this.x + thisClass.delta; this.component.y = this.y + thisClass.delta; var posObject = new Object(); posObject.x = this.component.x; posObject.y = this.component.y; if (this.component.prevEcoordinates != null) { this.component.ecoordinates = this.component.prevEcoordinates; } if (undo) { this.component.e2xml.addPropObject('ecoordinates', posObject); } else { this.component.e2xml.addPropObject('ecoordinates', posObject, 'default'); } if (!this.component.AUTOSIZE) { this.component.width = this.width - (thisClass.delta * 2); this.component.height = this.height - (thisClass.delta * 2); } if (render) { this.component.render(false); } } }MF_Utils.rotate(thisClass.id, thisClass.angle); }; this.setAngle = function (undo, render, add) { if (undo == null) { undo = true; } if (render == null) { render = true; } if (add == null) { add = true; } if (this.component && !this.component.LOCK_POSITION) { if (add) { if (undo) { this.component.e2xml.addPropSingle('eangle', thisClass.angle); } else { this.component.e2xml.addPropSingle('eangle', thisClass.angle, 'default'); } }MF_Utils.rotate(thisClass.id, thisClass.angle); if (render) { this.component.render(false); } } else { return; const undoarr = new Array(); for (let i = 0; i < mf_main.editorController.componentSelect.length; i++) { const select = mf_main.editorController.componentSelect[i]; if (!select.locked) { select.angle = thisClass.angle; if (select.GROUP) { const arr = mf_main.editorController.reAngleComponents(select, false); for (let j = 0; j < arr.length; j++) { const udo = arr[j]; undoarr[undoarr.length] = udo; } } else if (select.component && select.component.TRANSFORM) {} else { select.component.e2xml.addPropSingle('eangle', thisClass.angle, 'default'); MF_Utils.rotate(select.id, thisClass.angle); } } } } }; this.setBalpha = function (val) { this.balpha = val; if (val == 0) { $(`#${this.id}`).css('background-color', 'transparent'); } else { $(`#${this.id}`).css('background-color', 'rgb(68,68,68,0.5)'); } }; this.getBalpha = function () { return this.balpha; }; this.setVisible = function (val) { this.visible = val; if ($(`#${this.id}`) != null) { if (this.visible) { $(`#${this.id}`).css('display', 'block'); if (thisClass.component) { if (thisClass.component.TRANSFORM) { $(`#${this.id}`).hide(); } } } else { $(`#${this.id}`).css('display', 'none'); } } }; this.setInActive = function (val) { if ($(`#${this.id}`) != null) { $(`#${this.id}`).css('background-color', 'rgba(255,255,255,0.8)'); } }; this.setActive = function (val) { if ($(`#${this.id}`) != null) { $(`#${this.id}`).css('background-color', 'transparent'); } }; this.setComponentVisible = function (val) { if (thisClass.component) { thisClass.visible = val; if ($(`#${thisClass.id}`) != null) { if (thisClass.visible) { $(`#${thisClass.id}`).css('display', 'block'); } else { $(`#${thisClass.id}`).css('display', 'none'); }thisClass.component.setVisible(val); if (thisClass.component) { if (thisClass.component.TRANSFORM) { $(`#${thisClass.id}`).hide(); } } } } }; this.getVisible = function () { return this.visible; }; this.setCurrentState = function (val) { this.currentState = val; }; this.getCurrentState = function () { return this.currentState; }; this.Select = function () { if (thisClass.GLOBAL_SELECT && !thisClass.GROUP) { thisClass.currentState = 'unselected'; } else {} }; this.UnSelect = function () {}; this.remove = function () { $(`#${this.id}`).remove(); }; this.render = function (redraw) { if (redraw == null) { redraw = true; } let rectCode = ''; const cwidth = this.width; const cheight = this.height; const ctop = this.y; const cleft = this.x; if (redraw) { $(`#${this.id}`).remove(); rectCode = `${rectCode}<div  unselectable="on"  id="${this.id}" group-id="${this.GROUPID}" class='sdrag' width="${(cwidth).toString()}" height="${(cheight).toString()}" style="overflow: hidden; -webkit-transform: translateZ(0);  -webkit-user-select: none; -moz-user-select: none; user-select:none; position:absolute; width:${(cwidth).toString()}px; height:${(cheight).toString()}px; top:${(ctop).toString()}px; left:${(cleft).toString()}px; " > `; rectCode = `${rectCode}<div id="${this.id}_base" width="${(cwidth - (thisClass.delta * 2)).toString()}" height="${(cheight - (thisClass.delta * 2)).toString()}" style="-webkit-transform: translateZ(0);  background-color: #878D99; opacity: 0.0; border: 0px solid; position:absolute; width:${(cwidth - (thisClass.delta * 2)).toString()}px; height:${(cheight - (thisClass.delta * 2)).toString()}px; top:${thisClass.delta.toString()}px; left:${thisClass.delta.toString()}px; " > `; rectCode += '</div>'; rectCode += '</div>'; $(`#mfPage${mf_main.editorController.page.eid}`).append(rectCode); } else { $(`#${this.id}`).css('left', this.x); $(`#${this.id}`).css('top', this.y); $(`#${this.id}`).css('width', this.width); $(`#${this.id}`).css('height', this.height); } if (thisClass.GLOBAL_SELECT && thisClass.GROUP == false) { $(`#${this.id}`).css('background-color', 'rgba(135,141,153,0.3)'); } if (thisClass.component) { if (thisClass.component.TRANSFORM) { $(`#${this.id}`).hide(); } }MF_Utils.rotate(thisClass.id, thisClass.angle); }; } function tabWedgeRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, height); ctx.lineTo(radius, x); ctx.lineTo(width - radius, y); ctx.lineTo(width, height); } function topWedgeRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, height); ctx.lineTo(radius, x); ctx.lineTo(width - radius, y); ctx.lineTo(width, height); } function rightRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + height); ctx.lineTo(x + width - radius, y + height); ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x, y); } function leftRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height - radius); ctx.quadraticCurveTo(x, y + height, x + radius, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); } function topRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); } function tabRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height); ctx.moveTo(x + width, y + height); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); } function topRoundRect2(ctx, x, y, w, h, cornerRadius) {
  cornerRadius /= 2; ctx.beginPath(); let theta,
    angle,
    cx,
    cy,
    px,
    py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + w - cornerRadius, y); angle = -Math.PI / 2; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + w, y + h - cornerRadius); const brc = 0; angle += theta; cx = x + w - brc + (Math.cos(angle + (theta / 2)) * brc / Math.cos(theta / 2)); cy = y + h - brc + (Math.sin(angle + (theta / 2)) * brc / Math.cos(theta / 2)); px = x + w - brc + (Math.cos(angle + theta) * brc); py = y + h - brc + (Math.sin(angle + theta) * brc); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - brc + (Math.cos(angle + (theta / 2)) * brc / Math.cos(theta / 2)); cy = y + h - brc + (Math.sin(angle + (theta / 2)) * brc / Math.cos(theta / 2)); px = x + w - brc + (Math.cos(angle + theta) * brc); py = y + h - brc + (Math.sin(angle + theta) * brc); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + cornerRadius, y + h); angle += theta; const blr = 0; cx = x + blr + (Math.cos(angle + (theta / 2)) * blr / Math.cos(theta / 2)); cy = y + h - blr + (Math.sin(angle + (theta / 2)) * blr / Math.cos(theta / 2)); px = x + blr + (Math.cos(angle + theta) * blr); py = y + h - blr + (Math.sin(angle + theta) * blr); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + blr + (Math.cos(angle + (theta / 2)) * blr / Math.cos(theta / 2)); cy = y + h - blr + (Math.sin(angle + (theta / 2)) * blr / Math.cos(theta / 2)); px = x + blr + (Math.cos(angle + theta) * blr); py = y + h - blr + (Math.sin(angle + theta) * blr); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x, y + cornerRadius); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py);
} function bottomRoundRect2(ctx, x, y, w, h, cornerRadius) {
  cornerRadius /= 2; ctx.beginPath(); let theta,
    angle,
    cx,
    cy,
    px,
    py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + w - cornerRadius, y); angle = -Math.PI / 2; const trad = 0; cx = x + w - trad + (Math.cos(angle + (theta / 2)) * trad / Math.cos(theta / 2)); cy = y + trad + (Math.sin(angle + (theta / 2)) * trad / Math.cos(theta / 2)); px = x + w - trad + (Math.cos(angle + theta) * trad); py = y + trad + (Math.sin(angle + theta) * trad); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - trad + (Math.cos(angle + (theta / 2)) * trad / Math.cos(theta / 2)); cy = y + trad + (Math.sin(angle + (theta / 2)) * trad / Math.cos(theta / 2)); px = x + w - trad + (Math.cos(angle + theta) * trad); py = y + trad + (Math.sin(angle + theta) * trad); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + w, y + h - cornerRadius); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + cornerRadius, y + h); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x, y + cornerRadius); angle += theta; cx = x + trad + (Math.cos(angle + (theta / 2)) * trad / Math.cos(theta / 2)); cy = y + trad + (Math.sin(angle + (theta / 2)) * trad / Math.cos(theta / 2)); px = x + trad + (Math.cos(angle + theta) * trad); py = y + trad + (Math.sin(angle + theta) * trad); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + trad + (Math.cos(angle + (theta / 2)) * trad / Math.cos(theta / 2)); cy = y + trad + (Math.sin(angle + (theta / 2)) * trad / Math.cos(theta / 2)); px = x + trad + (Math.cos(angle + theta) * trad); py = y + trad + (Math.sin(angle + theta) * trad); ctx.quadraticCurveTo(cx, cy, px, py);
} function roundedRect2(ctx, x, y, w, h, cornerRadius) {
  cornerRadius /= 2; ctx.beginPath(); let theta,
    angle,
    cx,
    cy,
    px,
    py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + w - cornerRadius, y); angle = -Math.PI / 2; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + w, y + h - cornerRadius); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + cornerRadius, y + h); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x, y + cornerRadius); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py);
} function sketchRoundedRect(rough, x, y, w, h, cornerRadius) {
  cornerRadius /= 2; let theta,
    angle,
    cx,
    cy,
    px,
    py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; rough.line(x + (cornerRadius / 2), y, x + w - (cornerRadius / 2), y); angle = -Math.PI / 2; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); let c1 = cx; let c2 = cy; let p1 = px; let p2 = py; angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); rough.curve([[c1, c2], [p1, p2], [cx, cy], [px, py]]); rough.line(px, py, x + w, y + h - (cornerRadius / 2)); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); c1 = cx; c2 = cy; p1 = px; p2 = py; angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); rough.curve([[c1, c2], [p1, p2], [cx, cy], [px, py]]); rough.line(px, py, x + (cornerRadius / 2), y + h); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); c1 = cx; c2 = cy; p1 = px; p2 = py; angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); rough.curve([[c1, c2], [p1, p2], [cx, cy], [px, py]]); rough.line(px, py, x, y + (cornerRadius / 2)); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); c1 = cx; c2 = cy; p1 = px; p2 = py; angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); rough.curve([[c1, c2], [p1, p2], [cx, cy], [px, py]]);
} function MF_FontController() { const thisClass = this; this.fontArray = new Array(); this.googleFontArray = new Array(); this.icons = new Array(); this.googleFontFamilyItems = null; this.googleSearchedFonts = null; this.googleFontSliceStartIndex = 0; this.googleFontSliceEndIndex = 50; this.currentFontType = 'BuiltIn'; this.googleSearchedFontSliceStartIndex = 0; this.googleSearchedFontSliceEndIndex = 50; this.usedFonts = new Object(); this.loadedFonts = new Object(); this.fontActive = new Array(); this.constructor = function () { thisClass.addFonts(); thisClass.addIcons(); const fontObj = new MF_Font(); fontObj.id = 'sourcesanspro'; fontObj.name = 'Source Sans Pro'; fontObj.type = 'Source Sans Pro'; fontObj.fontFamily = 'Source Sans Pro'; fontObj.embedded = true; fontObj.isGoogleFont = true; thisClass.usedFonts.sourcesanspro = fontObj; }; this.addGoogleFontToArray = function (fontFamily) { let fontPresent = false; for (let i = 0; i < thisClass.googleFontArray.length; i++) { const font = thisClass.googleFontArray[i]; if (font.type == fontFamily) { fontPresent = true; break; } } if (!fontPresent) { const fontObj = new MF_Font(); fontObj.id = fontFamily; fontObj.name = fontFamily; fontObj.type = fontFamily; fontObj.embedded = true; fontObj.isGoogleFont = true; thisClass.googleFontArray.push(fontObj); } }; this.updateFontArrayWithGoogleFont = function () { for (const key in thisClass.usedFonts) { const font = thisClass.usedFonts[key]; const fontFamily = font.fontFamily; const fontObj = new MF_Font(); fontObj.id = fontFamily; fontObj.name = fontFamily; fontObj.type = fontFamily; fontObj.embedded = true; fontObj.isGoogleFont = true; thisClass.fontArray.push(fontObj); } }; this.loadFont = function (fontid, component, x, y) { let fontLoaded = false; if (thisClass.loadedFonts[fontid]) { fontLoaded = true; } if (fontid == 'sourcesanspro' || fontid == 'SourceSans Pro' || fontid == 'Source Sans Pro') { fontid = 'sourcesanspro'; fontLoaded = true; thisClass.loadedFonts[fontid] = true; } if (!fontLoaded) { const fontObj = thisClass.getFontByID(fontid); if (fontObj) { thisClass.loadedFonts[fontObj.id] = true; } if (fontObj && fontObj.embedded) { WebFontConfig = { custom: { families: [fontObj.type, 'icomoon'], urls: [`https://wireframepro.mockflow.com/css/fonts/${fontObj.id}/stylesheet.css`] }, inactive() { mf_main.closeDialog(); thisClass.fontActive[fontObj.id] = true; if (component != null) { mf_main.editorController.loadNewComponent(component, x, y); mf_main.editorController.addSelectorResize(component.selector); } }, active() { mf_main.closeDialog(); thisClass.fontActive[fontObj.id] = true; if (component != null) { mf_main.editorController.loadNewComponent(component, x, y); mf_main.editorController.addSelectorResize(component.selector); } let idname = null; idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', fontObj.type); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', fontObj.type); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', fontObj.type); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'italic'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', fontObj.type); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'italic'); } }; (function () { const wf = document.createElement('script'); wf.src = 'https://wireframepro.mockflow.com/js/external/webfont.js'; wf.type = 'text/javascript'; wf.async = 'true'; const s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(wf, s); }()); } else { mf_main.closeDialog(); thisClass.fontActive[fontObj.id] = true; if (component != null) { mf_main.editorController.loadNewComponent(component, x, y); mf_main.editorController.addSelectorResize(component.selector); } } } else { mf_main.closeDialog(); if (component != null) { mf_main.editorController.loadNewComponent(component, x, y); mf_main.editorController.addSelectorResize(component.selector); } } }; this.loadAllFonts = function () { const fonturls = new Array(); const fontfamilies = new Array(); const googleFontFamilies = new Array(); const builtinfonts = new Object(); for (var key in thisClass.usedFonts) { if (key == 'sourcesanspro' || key == 'SourceSans Pro' || key == 'Source Sans Pro') { key = 'sourcesanspro'; thisClass.loadedFonts[key] = true; } if (thisClass.loadedFonts[key] != true) { var font = thisClass.usedFonts[key]; if (font.isGoogleFont) { googleFontFamilies.push(font.fontFamily); } else { const fontobj = thisClass.getFontByID(font.fontFamily); if (fontobj && fontobj.embedded) { fonturls.push(`https://wireframepro.mockflow.com/css/fonts/${fontobj.id}/stylesheet.css`); fontfamilies.push(fontobj.type); builtinfonts[fontobj] = true; } if (fontobj) { thisClass.loadedFonts[fontobj.id] = true; } } } } if (fonturls.length == 0 && googleFontFamilies.length == 0) { for (var key in builtinfonts) { var font = builtinfonts[key]; thisClass.fontActive[font.fontFamily] = true; } } else { WebFontConfig = { custom: { families: fontfamilies, urls: fonturls }, inactive() { for (const key in builtinfonts) { const font = builtinfonts[key]; thisClass.fontActive[font.fontFamily] = true; let idname = null; idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'italic'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'italic'); } }, active() { for (const key in builtinfonts) { const font = builtinfonts[key]; thisClass.fontActive[font.fontFamily] = true; let idname = null; idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'normal'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'normal'); $(`#${idname}`).css('font-style', 'italic'); idname = `mfTextDummy${mf_main.editorController.guidGenerator()}`; $('#mfTextDummy').append(`<span  id="${idname}" >&nbsp;</span>`); $(`#${idname}`).css('font-family', font.fontFamily); $(`#${idname}`).css('font-weight', 'bold'); $(`#${idname}`).css('font-style', 'italic'); } } }; if (googleFontFamilies.length > 0) { for (const googleFontIndex in googleFontFamilies) { const tempFontFamily = googleFontFamilies[googleFontIndex]; if (tempFontFamily == 'Architects Daughter' || tempFontFamily == 'architectsdaughter') { WebFontConfig.custom.families.push('Architects Daughter'); WebFontConfig.custom.urls.push('https://wireframepro.mockflow.com/css/fonts/architectsdaughter/stylesheet.css'); googleFontFamilies.splice(googleFontIndex, 1); break; } } if (typeof GOOGLEFONTLIST !== 'undefined') { WebFontConfig.google = { families: GOOGLEFONTLIST.split(',') }; } else { WebFontConfig.google = { families: googleFontFamilies }; } }(function () { const wf = document.createElement('script'); wf.src = 'https://wireframepro.mockflow.com/js/external/webfont.js'; wf.type = 'text/javascript'; wf.async = 'true'; const s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(wf, s); }()); } }; this.addFonts = function () { thisClass.fontArray = new Array(); let fontObj; fontObj = new MF_Font(); fontObj.id = 'mockflowfont1'; fontObj.name = 'MockFlow Font1'; fontObj.type = "'MockFlowFont1'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'mockflowfont2'; fontObj.name = 'MockFlow Font2'; fontObj.type = "'MockFlowFont2'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'blokk-neueregular'; fontObj.name = 'Block Font 1'; fontObj.type = "'BLOKKNeue-Regular'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'redacted-scriptbold'; fontObj.name = 'Script Bold'; fontObj.type = "'redacted_scriptbold'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'redacted-scriptlight'; fontObj.name = 'Script Light'; fontObj.type = "'redacted_scriptlight'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'redacted-scriptregular'; fontObj.name = 'Script Regular'; fontObj.type = "'redacted_scriptregular'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'redacted-regular'; fontObj.name = 'Block Font'; fontObj.type = "'redactedregular'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'ubuntu'; fontObj.name = 'Ubuntu'; fontObj.type = "'UbuntuFont'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'roboto'; fontObj.name = 'Roboto'; fontObj.type = "'RobotoFont'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'cartoonist'; fontObj.name = 'Cartoonist'; fontObj.type = "'SFCartoonistFont'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'blokletters'; fontObj.name = 'BlokLetters'; fontObj.type = "'BloklettersFont'"; fontObj.embedded = true; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'arial'; fontObj.name = 'Arial'; fontObj.type = "'Arial'"; fontObj.embedded = false; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'times'; fontObj.name = 'times'; fontObj.type = "'Times'"; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'courier'; fontObj.name = 'Courier'; fontObj.type = "'Courier'"; fontObj.embedded = false; thisClass.fontArray.push(fontObj); fontObj = new MF_Font(); fontObj.id = 'sourcesanspro'; fontObj.name = 'SourceSansPro'; fontObj.type = "'Source Sans Pro'"; fontObj.embedded = false; thisClass.fontArray.push(fontObj); }; this.getFontByID = function (id) { let i = 0; for (i = 0; i <= thisClass.fontArray.length - 1; i++) { const fontObj = thisClass.fontArray[i]; if (fontObj.id == id) { return fontObj; } } return null; }; this.getFontByIDComponent = function (id, component) { let fontFamily = 'Source Sans Pro'; if (component.isGoogleFontUsed) { fontFamily = component.fontType; } else { const fontObj = thisClass.getFontByID(component.fontType); if (fontObj) { fontFamily = fontObj.type; } } return fontFamily; }; this.updateFontArrayWithGoogleFont = function () { for (const key in thisClass.usedFonts) { const font = thisClass.usedFonts[key]; const fontFamily = font.fontFamily; const fontObj = new MF_Font(); fontObj.id = fontFamily; fontObj.name = fontFamily; fontObj.type = fontFamily; fontObj.embedded = true; fontObj.isGoogleFont = true; thisClass.fontArray.push(fontObj); } }; this.addIcons = function () { thisClass.icons = ['ico-up3_filled', 'ico-up2_filled', 'ico-right2_filled', 'ico-forward', 'ico-back', 'ico-angle-down-circle', 'ico-angle-down', 'ico-angle-left-circle', 'ico-angle-right-circle', 'ico-angle-left', 'ico-angle-right', 'ico-angle-up-circle', 'ico-angle-up', 'ico-back2', 'ico-back-2', 'ico-up2', 'ico-up3', 'ico-right3', 'ico-up4', 'ico-up', 'ico-left3', 'ico-right2', 'ico-right', 'ico-left', 'ico-left2', 'ico-down3', 'ico-down4', 'ico-down', 'ico-down2', 'ico-cloud-download', 'ico-cloud-upload', 'ico-download_from_cloud', 'ico-bottom-arrow', 'ico-left-arrow', 'ico-right-arrow', 'ico-upload_to_cloud', 'ico-exit', 'ico-enter', 'ico-external_link', 'ico-flip_vertical', 'ico-flip_horizontal', 'ico-upload', 'ico-download', 'ico-rewind', 'ico-fast_forward', 'ico-rewind', 'ico-advance', 'ico-export', 'ico-paper-plane', 'ico-gps_device', 'ico-sent', 'ico-sent_filled', 'ico-rotation_cw', 'ico-rotation_ccw', 'ico-rotate_left', 'ico-rotate_right', 'ico-refresh', 'ico-update', 'ico-reload', 'ico-replace', 'ico-upload_to_cloud_filled', 'ico-upload_to_cloud_filled2', 'ico-right-arrow', 'ico-bottom-arrow', 'ico-export', 'ico-buy_upgrade_filled', 'ico-user_male_filled', 'ico-user_female_circle_filled', 'ico-user_male2', 'ico-worker_filled', 'ico-user_male_circle', 'ico-user_male', 'ico-user_female', 'ico-user_female_circle', 'ico-remove_user', 'ico-group', 'ico-find_user', 'ico-edit_user', 'ico-checked_user', 'ico-administrator', 'ico-user_male_3', 'ico-add_user', 'ico-users', 'ico-user_female_4', 'ico-user_female_3', 'ico-vip_filled', 'ico-vip', 'ico-cloud', 'ico-shared', 'ico-speech_bubble', 'ico-cloud_storage', 'ico-drawer', 'ico-shared_filled', 'ico-about_filled', 'ico-speech_bubble_filled', 'ico-ask_question', 'ico-about', 'ico-help1', 'ico-topic', 'ico-help', 'ico-flag2_filled', 'ico-flag_filled', 'ico-flag', 'ico-flag2', 'ico-electric_megaphone', 'ico-price_tag_USD_filled', 'ico-price_tag_filled', 'ico-price_tag', 'ico-buy_upgrade', 'ico-cheap_2', 'ico-us_dollar', 'ico-bitcoin', 'ico-star_filled', 'ico-star', 'ico-add_to_favorites', 'ico-smile', 'ico-wink', 'ico-sad', 'ico-lol', 'ico-happy', 'ico-reply', 'ico-forward2', 'ico-forward22', 'ico-inspection', 'ico-diploma', 'ico-select_all', 'ico-invite', 'ico-message', 'ico-create_new', 'ico-deleted_message', 'ico-message_group', 'ico-replay', 'ico-mail-open-file', 'ico-mail-open', 'ico-view_file', 'ico-read_message', 'ico-paste', 'ico-paste_special', 'ico-survey', 'ico-bill', 'ico-note', 'ico-note2', 'ico-survey', 'ico-copy', 'ico-document', 'ico-check', 'ico-close2', 'ico-close-circle', 'ico-close', 'ico-near_me', 'ico-less', 'ico-plus2', 'ico-poor_quality', 'ico-good_quality', 'ico-folder_filled', 'ico-folder', 'ico-opened_folder_filled', 'ico-opened_folder', 'ico-xlarge_icons', 'ico-system_report', 'ico-presentation', 'ico-stack_of_photos', 'ico-photo-gallery', 'ico-combo_chart', 'ico-photo', 'ico-phone1', 'ico-multiple_devices', 'ico-iphone_copyrighted', 'ico-ipad_copyrighted', 'ico-display1', 'ico-albums', 'ico-tv_show', 'ico-system_information', 'ico-picture', 'ico-workstation', 'ico-code', 'ico-business', 'ico-briefcase', 'ico-copy', 'ico-document', 'ico-video_camera_filled', 'ico-micro', 'ico-mouse2', 'ico-mouse', 'ico-camera', 'ico-web_camera', 'ico-video_camera', 'ico-high_volume', 'ico-mute', 'ico-waste', 'ico-trash2', 'ico-trash', 'ico-trash_filled', 'ico-calendar', 'ico-date', 'ico-clock', 'ico-alarm_clock', 'ico-today', 'ico-leave', 'ico-watch', 'ico-like_filled', 'ico-hearts', 'ico-dislike', 'ico-like3', 'ico-like', 'ico-drop', 'ico-blur', 'ico-location', 'ico-user_shield', 'ico-shield', 'ico-delete_shield', 'ico-geo_fence', 'ico-map_marker', 'ico-paint_bucket', 'ico-background_color', 'ico-paint_basket', 'ico-paint_palette', 'ico-paint_brush', 'ico-color_dropper', 'ico-chisel_tip_marker', 'ico-brush', 'ico-border_color', 'ico-ball_point_pen', 'ico-roller_brush', 'ico-cardboard_box', 'ico-sign_up', 'ico-menu_filled', 'ico-QR_code', 'ico-visible_filled', 'ico-birthday', 'ico-thumbnails', 'ico-paid', 'ico-fantasy', 'ico-albums', 'ico-attention', 'ico-ball', 'ico-bell', 'ico-box1', 'ico-box2', 'ico-browser', 'ico-checkmark', 'ico-config', 'ico-edit2', 'ico-expand1', 'ico-filter2', 'ico-gleam', 'ico-help22', 'ico-home2', 'ico-keypad', 'ico-light', 'ico-link2', 'ico-look', 'ico-loop', 'ico-more', 'ico-shuffle', 'ico-tools', 'ico-hashtag', 'ico-numbered_list', 'ico-insert_table', 'ico-horizontal_line', 'ico-infinity', 'ico-password2', 'ico-password', 'ico-medium_priority', 'ico-box', 'ico-settings_wrench', 'ico-drafting_compass', 'ico-to_do', 'ico-settings3', 'ico-plus', 'ico-minus', 'ico-menu', 'ico-error', 'ico-email', 'ico-delete_sign', 'ico-checklist', 'ico-wifi', 'ico-domain', 'ico-bluetooth', 'ico-christmas_star', 'ico-credit_card', 'ico-banknotes', 'ico-resize', 'ico-rename', 'ico-pen', 'ico-line', 'ico-italic', 'ico-increase_font', 'ico-eraser', 'ico-ellipse', 'ico-edit', 'ico-cut', 'ico-shopping_cart_empty', 'ico-shopping_bag', 'ico-shop', 'ico-put_in', 'ico-gift', 'ico-empty_box', 'ico-workflow', 'ico-pie_chart', 'ico-mind_map', 'ico-flow_chart', 'ico-recycle_sign_filled', 'ico-recycle_sign', 'ico-questions', 'ico-answers', 'ico-zoom_out', 'ico-zoom_in', 'ico-unlock_filled', 'ico-unlock', 'ico-share', 'ico-settings', 'ico-search', 'ico-plugin', 'ico-paper_clip', 'ico-lock_filled', 'ico-lock', 'ico-key', 'ico-info', 'ico-idea', 'ico-home', 'ico-help2', 'ico-filter', 'ico-design', 'ico-cancel', 'ico-bookmark', 'ico-binoculars', 'ico-archive', 'ico-visible', 'ico-rss', 'ico-pin', 'ico-online', 'ico-link_broken', 'ico-link', 'ico-invisible', 'ico-inbox', 'ico-contacts', 'ico-contact_card', 'ico-stop', 'ico-globe', 'ico-engineering', 'ico-automatic', 'ico-print', 'ico-airport', 'fa-500px', 'fa-adjust', 'fa-adn', 'fa-align-center', 'fa-align-justify', 'fa-align-left', 'fa-align-right', 'fa-amazon', 'fa-ambulance', 'fa-american-sign-language-interpreting', 'fa-anchor', 'fa-android', 'fa-angellist', 'fa-angle-double-down', 'fa-angle-double-left', 'fa-angle-double-right', 'fa-angle-double-up', 'fa-angle-down', 'fa-angle-left', 'fa-angle-right', 'fa-angle-up', 'fa-apple', 'fa-archive', 'fa-area-chart', 'fa-arrow-circle-down', 'fa-arrow-circle-left', 'fa-arrow-circle-o-down', 'fa-arrow-circle-o-left', 'fa-arrow-circle-o-right', 'fa-arrow-circle-o-up', 'fa-arrow-circle-right', 'fa-arrow-circle-up', 'fa-arrow-down', 'fa-arrow-left', 'fa-arrow-right', 'fa-arrow-up', 'fa-arrows', 'fa-arrows-alt', 'fa-arrows-h', 'fa-arrows-v', 'fa-assistive-listening-systems', 'fa-asterisk', 'fa-at', 'fa-audio-description', 'fa-backward', 'fa-balance-scale', 'fa-ban', 'fa-bar-chart', 'fa-barcode', 'fa-bars', 'fa-battery-empty', 'fa-battery-full', 'fa-battery-half', 'fa-battery-quarter', 'fa-battery-three-quarters', 'fa-bed', 'fa-beer', 'fa-behance', 'fa-behance-square', 'fa-bell', 'fa-bell-o', 'fa-bell-slash', 'fa-bell-slash-o', 'fa-bicycle', 'fa-binoculars', 'fa-birthday-cake', 'fa-bitbucket', 'fa-bitbucket-square', 'fa-black-tie', 'fa-blind', 'fa-bluetooth', 'fa-bluetooth-b', 'fa-bold', 'fa-bolt', 'fa-bomb', 'fa-book', 'fa-bookmark', 'fa-bookmark-o', 'fa-braille', 'fa-briefcase', 'fa-btc', 'fa-bug', 'fa-building', 'fa-building-o', 'fa-bullhorn', 'fa-bullseye', 'fa-bus', 'fa-buysellads', 'fa-calculator', 'fa-calendar', 'fa-calendar-check-o', 'fa-calendar-minus-o', 'fa-calendar-o', 'fa-calendar-plus-o', 'fa-calendar-times-o', 'fa-camera', 'fa-camera-retro', 'fa-car', 'fa-caret-down', 'fa-caret-left', 'fa-caret-right', 'fa-caret-square-o-down', 'fa-caret-square-o-left', 'fa-caret-square-o-right', 'fa-caret-square-o-up', 'fa-caret-up', 'fa-cart-arrow-down', 'fa-cart-plus', 'fa-cc', 'fa-cc-amex', 'fa-cc-diners-club', 'fa-cc-discover', 'fa-cc-jcb', 'fa-cc-mastercard', 'fa-cc-paypal', 'fa-cc-stripe', 'fa-cc-visa', 'fa-certificate', 'fa-chain-broken', 'fa-check', 'fa-check-circle', 'fa-check-circle-o', 'fa-check-square', 'fa-check-square-o', 'fa-chevron-circle-down', 'fa-chevron-circle-left', 'fa-chevron-circle-right', 'fa-chevron-circle-up', 'fa-chevron-down', 'fa-chevron-left', 'fa-chevron-right', 'fa-chevron-up', 'fa-child', 'fa-chrome', 'fa-circle', 'fa-circle-o', 'fa-circle-o-notch', 'fa-circle-thin', 'fa-clipboard', 'fa-clock-o', 'fa-clone', 'fa-cloud', 'fa-cloud-download', 'fa-cloud-upload', 'fa-code', 'fa-code-fork', 'fa-codepen', 'fa-codiepie', 'fa-coffee', 'fa-cog', 'fa-cogs', 'fa-columns', 'fa-comment', 'fa-comment-o', 'fa-commenting', 'fa-commenting-o', 'fa-comments', 'fa-comments-o', 'fa-compass', 'fa-compress', 'fa-connectdevelop', 'fa-contao', 'fa-copyright', 'fa-creative-commons', 'fa-credit-card', 'fa-credit-card-alt', 'fa-crop', 'fa-crosshairs', 'fa-css3', 'fa-cube', 'fa-cubes', 'fa-cutlery', 'fa-dashcube', 'fa-database', 'fa-deaf', 'fa-delicious', 'fa-desktop', 'fa-deviantart', 'fa-diamond', 'fa-digg', 'fa-dot-circle-o', 'fa-download', 'fa-dribbble', 'fa-dropbox', 'fa-drupal', 'fa-edge', 'fa-eject', 'fa-ellipsis-h', 'fa-ellipsis-v', 'fa-empire', 'fa-envelope', 'fa-envelope-o', 'fa-envelope-square', 'fa-envira', 'fa-eraser', 'fa-eur', 'fa-exchange', 'fa-exclamation', 'fa-exclamation-circle', 'fa-exclamation-triangle', 'fa-expand', 'fa-expeditedssl', 'fa-external-link', 'fa-external-link-square', 'fa-eye', 'fa-eye-slash', 'fa-eyedropper', 'fa-facebook', 'fa-facebook-official', 'fa-facebook-square', 'fa-fast-backward', 'fa-fast-forward', 'fa-fax', 'fa-female', 'fa-fighter-jet', 'fa-file', 'fa-file-archive-o', 'fa-file-audio-o', 'fa-file-code-o', 'fa-file-excel-o', 'fa-file-image-o', 'fa-file-o', 'fa-file-pdf-o', 'fa-file-powerpoint-o', 'fa-file-text', 'fa-file-text-o', 'fa-file-video-o', 'fa-file-word-o', 'fa-files-o', 'fa-film', 'fa-filter', 'fa-fire', 'fa-fire-extinguisher', 'fa-firefox', 'fa-first-order', 'fa-flag', 'fa-flag-checkered', 'fa-flag-o', 'fa-flask', 'fa-flickr', 'fa-floppy-o', 'fa-folder', 'fa-folder-o', 'fa-folder-open', 'fa-folder-open-o', 'fa-font', 'fa-font-awesome', 'fa-fonticons', 'fa-fort-awesome', 'fa-forumbee', 'fa-forward', 'fa-foursquare', 'fa-frown-o', 'fa-futbol-o', 'fa-gamepad', 'fa-gavel', 'fa-gbp', 'fa-genderless', 'fa-get-pocket', 'fa-gg', 'fa-gg-circle', 'fa-gift', 'fa-git', 'fa-git-square', 'fa-github', 'fa-github-alt', 'fa-github-square', 'fa-gitlab', 'fa-glass', 'fa-glide', 'fa-glide-g', 'fa-globe', 'fa-google', 'fa-google-plus', 'fa-google-plus-official', 'fa-google-plus-square', 'fa-google-wallet', 'fa-graduation-cap', 'fa-gratipay', 'fa-h-square', 'fa-hacker-news', 'fa-hand-lizard-o', 'fa-hand-o-down', 'fa-hand-o-left', 'fa-hand-o-right', 'fa-hand-o-up', 'fa-hand-paper-o', 'fa-hand-peace-o', 'fa-hand-pointer-o', 'fa-hand-rock-o', 'fa-hand-scissors-o', 'fa-hand-spock-o', 'fa-hashtag', 'fa-hdd-o', 'fa-header', 'fa-headphones', 'fa-heart', 'fa-heart-o', 'fa-heartbeat', 'fa-history', 'fa-home', 'fa-hospital-o', 'fa-hourglass', 'fa-hourglass-end', 'fa-hourglass-half', 'fa-hourglass-o', 'fa-hourglass-start', 'fa-houzz', 'fa-html5', 'fa-i-cursor', 'fa-ils', 'fa-inbox', 'fa-indent', 'fa-industry', 'fa-info', 'fa-info-circle', 'fa-inr', 'fa-instagram', 'fa-internet-explorer', 'fa-ioxhost', 'fa-italic', 'fa-joomla', 'fa-jpy', 'fa-jsfiddle', 'fa-key', 'fa-keyboard-o', 'fa-krw', 'fa-language', 'fa-laptop', 'fa-lastfm', 'fa-lastfm-square', 'fa-leaf', 'fa-leanpub', 'fa-lemon-o', 'fa-level-down', 'fa-level-up', 'fa-life-ring', 'fa-lightbulb-o', 'fa-line-chart', 'fa-link', 'fa-linkedin', 'fa-linkedin-square', 'fa-linux', 'fa-list', 'fa-list-alt', 'fa-list-ol', 'fa-list-ul', 'fa-location-arrow', 'fa-lock', 'fa-long-arrow-down', 'fa-long-arrow-left', 'fa-long-arrow-right', 'fa-long-arrow-up', 'fa-low-vision', 'fa-magic', 'fa-magnet', 'fa-male', 'fa-map', 'fa-map-marker', 'fa-map-o', 'fa-map-pin', 'fa-map-signs', 'fa-mars', 'fa-mars-double', 'fa-mars-stroke', 'fa-mars-stroke-h', 'fa-mars-stroke-v', 'fa-maxcdn', 'fa-meanpath', 'fa-medium', 'fa-medkit', 'fa-meh-o', 'fa-mercury', 'fa-microphone', 'fa-microphone-slash', 'fa-minus', 'fa-minus-circle', 'fa-minus-square', 'fa-minus-square-o', 'fa-mixcloud', 'fa-mobile', 'fa-modx', 'fa-money', 'fa-moon-o', 'fa-motorcycle', 'fa-mouse-pointer', 'fa-music', 'fa-neuter', 'fa-newspaper-o', 'fa-object-group', 'fa-object-ungroup', 'fa-odnoklassniki', 'fa-odnoklassniki-square', 'fa-opencart', 'fa-openid', 'fa-opera', 'fa-optin-monster', 'fa-outdent', 'fa-pagelines', 'fa-paint-brush', 'fa-paper-plane', 'fa-paper-plane-o', 'fa-paperclip', 'fa-paragraph', 'fa-pause', 'fa-pause-circle', 'fa-pause-circle-o', 'fa-paw', 'fa-paypal', 'fa-pencil', 'fa-pencil-square', 'fa-pencil-square-o', 'fa-percent', 'fa-phone', 'fa-phone-square', 'fa-picture-o', 'fa-pie-chart', 'fa-pied-piper', 'fa-pied-piper-alt', 'fa-pied-piper-pp', 'fa-pinterest', 'fa-pinterest-p', 'fa-pinterest-square', 'fa-plane', 'fa-play', 'fa-play-circle', 'fa-play-circle-o', 'fa-plug', 'fa-plus', 'fa-plus-circle', 'fa-plus-square', 'fa-plus-square-o', 'fa-power-off', 'fa-print', 'fa-product-hunt', 'fa-puzzle-piece', 'fa-qq', 'fa-qrcode', 'fa-question', 'fa-question-circle', 'fa-question-circle-o', 'fa-quote-left', 'fa-quote-right', 'fa-random', 'fa-rebel', 'fa-recycle', 'fa-reddit', 'fa-reddit-alien', 'fa-reddit-square', 'fa-refresh', 'fa-registered', 'fa-renren', 'fa-repeat', 'fa-reply', 'fa-reply-all', 'fa-retweet', 'fa-road', 'fa-rocket', 'fa-rss', 'fa-rss-square', 'fa-rub', 'fa-safari', 'fa-scissors', 'fa-scribd', 'fa-search', 'fa-search-minus', 'fa-search-plus', 'fa-sellsy', 'fa-server', 'fa-share', 'fa-share-alt', 'fa-share-alt-square', 'fa-share-square', 'fa-share-square-o', 'fa-shield', 'fa-ship', 'fa-shirtsinbulk', 'fa-shopping-bag', 'fa-shopping-basket', 'fa-shopping-cart', 'fa-sign-in', 'fa-sign-language', 'fa-sign-out', 'fa-signal', 'fa-simplybuilt', 'fa-sitemap', 'fa-skyatlas', 'fa-skype', 'fa-slack', 'fa-sliders', 'fa-slideshare', 'fa-smile-o', 'fa-snapchat', 'fa-snapchat-ghost', 'fa-snapchat-square', 'fa-sort', 'fa-sort-alpha-asc', 'fa-sort-alpha-desc', 'fa-sort-amount-asc', 'fa-sort-amount-desc', 'fa-sort-asc', 'fa-sort-desc', 'fa-sort-numeric-asc', 'fa-sort-numeric-desc', 'fa-soundcloud', 'fa-space-shuttle', 'fa-spinner', 'fa-spoon', 'fa-spotify', 'fa-square', 'fa-square-o', 'fa-stack-exchange', 'fa-stack-overflow', 'fa-star', 'fa-star-half', 'fa-star-half-o', 'fa-star-o', 'fa-steam', 'fa-steam-square', 'fa-step-backward', 'fa-step-forward', 'fa-stethoscope', 'fa-sticky-note', 'fa-sticky-note-o', 'fa-stop', 'fa-stop-circle', 'fa-stop-circle-o', 'fa-street-view', 'fa-strikethrough', 'fa-stumbleupon', 'fa-stumbleupon-circle', 'fa-subscript', 'fa-subway', 'fa-suitcase', 'fa-sun-o', 'fa-superscript', 'fa-table', 'fa-tablet', 'fa-tachometer', 'fa-tag', 'fa-tags', 'fa-tasks', 'fa-taxi', 'fa-television', 'fa-tencent-weibo', 'fa-terminal', 'fa-text-height', 'fa-text-width', 'fa-th', 'fa-th-large', 'fa-th-list', 'fa-themeisle', 'fa-thumb-tack', 'fa-thumbs-down', 'fa-thumbs-o-down', 'fa-thumbs-o-up', 'fa-thumbs-up', 'fa-ticket', 'fa-times', 'fa-times-circle', 'fa-times-circle-o', 'fa-tint', 'fa-toggle-off', 'fa-toggle-on', 'fa-trademark', 'fa-train', 'fa-transgender', 'fa-transgender-alt', 'fa-trash', 'fa-trash-o', 'fa-tree', 'fa-trello', 'fa-tripadvisor', 'fa-trophy', 'fa-truck', 'fa-try', 'fa-tty', 'fa-tumblr', 'fa-tumblr-square', 'fa-twitch', 'fa-twitter', 'fa-twitter-square', 'fa-umbrella', 'fa-underline', 'fa-undo', 'fa-universal-access', 'fa-university', 'fa-unlock', 'fa-unlock-alt', 'fa-upload', 'fa-usb', 'fa-usd', 'fa-user', 'fa-user-md', 'fa-user-plus', 'fa-user-secret', 'fa-user-times', 'fa-users', 'fa-venus', 'fa-venus-double', 'fa-venus-mars', 'fa-viacoin', 'fa-viadeo', 'fa-viadeo-square', 'fa-video-camera', 'fa-vimeo', 'fa-vimeo-square', 'fa-vine', 'fa-vk', 'fa-volume-control-phone', 'fa-volume-down', 'fa-volume-off', 'fa-volume-up', 'fa-weibo', 'fa-weixin', 'fa-whatsapp', 'fa-wheelchair', 'fa-wheelchair-alt', 'fa-wifi', 'fa-wikipedia-w', 'fa-windows', 'fa-wordpress', 'fa-wpbeginner', 'fa-wpforms', 'fa-wrench', 'fa-xing', 'fa-xing-square', 'fa-y-combinator', 'fa-yahoo', 'fa-yelp', 'fa-yoast', 'fa-youtube', 'fa-youtube-play', 'fa-youtube-square']; }; } var MF_ComponentUtils = (function () {
  function privateMethod() {} return {
    setDimensions(thisClass, ecoordinates, esize) { if (ecoordinates != null) { thisClass.x = ecoordinates.x; thisClass.y = ecoordinates.y; } if (esize != null) { thisClass.width = esize.width; thisClass.height = esize.height; } },
    getRefactoredText(inputTxt) { inputTxt = inputTxt.replace(/</gi, '&lt;').replace(/>/gi, '&gt;'); inputTxt = inputTxt.replace(/&lt;br&gt;/gi, '<br>'); inputTxt = inputTxt.replace(/ /gi, '&nbsp;<wbr>'); return inputTxt; },
    setComponentShadow(ctx, shadowType) { if (shadowType == 'all') { ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(0, 0, 0, 0.6)'; } if (shadowType == 'top') { ctx.shadowOffsetX = 0; ctx.shadowOffsetY = -2; ctx.shadowBlur = 5; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; } if (shadowType == 'right') { ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 0; ctx.shadowBlur = 5; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; } if (shadowType == 'bottom') { ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 2; ctx.shadowBlur = 5; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; } if (shadowType == 'left') { ctx.shadowOffsetX = -2; ctx.shadowOffsetY = 0; ctx.shadowBlur = 5; ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; } },
    setComponentShadowImageCSS(domID, shadowType) { $(`#${domID}`).css('filter', 'none'); if (shadowType == 'all') { $(`#${domID}`).css('filter', 'drop-shadow(0 0 5px rgba(0, 0, 0, 0.5)'); } if (shadowType == 'top') { $(`#${domID}`).css('filter', 'drop-shadow(0px -4px 2px rgba(0, 0, 0, 0.5))'); } if (shadowType == 'right') { $(`#${domID}`).css('filter', 'drop-shadow(4px 0px 2px rgba(0, 0, 0, 0.5))'); } if (shadowType == 'bottom') { $(`#${domID}`).css('filter', 'drop-shadow(0px 4px 2px rgba(0, 0, 0, 0.5))'); } if (shadowType == 'left') { $(`#${domID}`).css('filter', 'drop-shadow(-4px 0px 2px rgba(0, 0, 0, 0.5))'); } },
    setComponentShadowCSS(domID, shadowType) { $(`#${domID}`).css('box-shadow', 'none'); if (shadowType == 'all') { $(`#${domID}`).css('box-shadow', '0 0 5px #333'); } if (shadowType == 'top') { $(`#${domID}`).css('box-shadow', '0 -5px 5px -5px #333'); } if (shadowType == 'right') { $(`#${domID}`).css('box-shadow', '5px 0 5px -5px #333'); } if (shadowType == 'bottom') { $(`#${domID}`).css('box-shadow', '0 5px 5px -5px #333'); } if (shadowType == 'left') { $(`#${domID}`).css('box-shadow', '-5px 0 5px -5px #333'); } },
    getRefactoredText2(inputTxt) { inputTxt = inputTxt.replace(/</gi, '&lt;').replace(/>/gi, '&gt;'); inputTxt = inputTxt.replace(/&lt;br&gt;/gi, '<br>'); inputTxt = inputTxt.replace(/ /gi, '&nbsp;'); return inputTxt; },
    nl2br(str, is_xhtml) { const breakTag = '<br />'; return (`${str}`).replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, `$1${breakTag}$2`); },
    commonPallete() { return ['#ffffff', '#FAFAFA', '#F5F5F5', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#616161', '#424242', '#212121', '#000000', '#f44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FF9800', '#795548', '#607D8B']; },
    setDimensionsTransform(thisClass, ecoordinates, esize) { if (ecoordinates != null) { thisClass.startX = ecoordinates.startX; thisClass.startY = ecoordinates.startY; thisClass.endX = ecoordinates.endX; thisClass.endY = ecoordinates.endY; } if (esize != null) { thisClass.width = esize.width; thisClass.height = esize.height; } },
    clearPage(thisClass) { if (document.getElementById(thisClass.eid)) { const ctx_cvs = (document.getElementById(thisClass.eid)).getContext('2d'); if (ctx_cvs) { ctx_cvs.clearRect(0, 0, $(`#${thisClass.eid}`).width(), $(`#${thisClass.eid}`).height()); document.getElementById(thisClass.eid).width = thisClass.width; $(`#${thisClass.eid}`).css('left', thisClass.x); $(`#${thisClass.eid}`).css('top', thisClass.y); $(`#${thisClass.eid}`).css('width', thisClass.width); $(`#${thisClass.eid}`).css('height', thisClass.height); document.getElementById(thisClass.eid).width = thisClass.width; document.getElementById(thisClass.eid).height = thisClass.height; } } },
    hexToRGB(hex, alpha) { hex = `0x${hex.replace('#', '')}`; alpha = typeof (alpha) !== 'undefined' ? alpha : '1'; const rgbObj = { red: ((hex & 16711680) >> 16), green: ((hex & 65280) >> 8), blue: ((hex & 255)) }; return `rgba(${rgbObj.red},${rgbObj.green},${rgbObj.blue},${alpha})`; },
    hexToRGB2(hex, alpha) { hex = `0x${hex.replace('#', '')}`; alpha = typeof (alpha) !== 'undefined' ? alpha : '1'; const rgbObj = { red: ((hex & 16711680) >> 16), green: ((hex & 65280) >> 8), blue: ((hex & 255)) }; return `${rgbObj.red},${rgbObj.green},${rgbObj.blue}`; },
    randomInRange(min, max) { const scale = max - min; return Math.floor(Math.random() * scale + min); },
    atLevel(str) { let level = 0; for (let i = 0; i < str.length; i++) { if (str.charAt(i) == '*') { level++; } else { break; } } return level; },
    roundedRect2(ctx, x, y, w, h, cornerRadius) {
      cornerRadius /= 2; ctx.beginPath(); let theta,
        angle,
        cx,
        cy,
        px,
        py; if (cornerRadius > Math.min(w, h) / 2) { cornerRadius = Math.min(w, h) / 2; }theta = Math.PI / 4; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + w - cornerRadius, y); angle = -Math.PI / 2; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + w, y + h - cornerRadius); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + w - cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + w - cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x + cornerRadius, y + h); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + h - cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + h - cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.lineTo(x, y + cornerRadius); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); angle += theta; cx = x + cornerRadius + (Math.cos(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); cy = y + cornerRadius + (Math.sin(angle + (theta / 2)) * cornerRadius / Math.cos(theta / 2)); px = x + cornerRadius + (Math.cos(angle + theta) * cornerRadius); py = y + cornerRadius + (Math.sin(angle + theta) * cornerRadius); ctx.quadraticCurveTo(cx, cy, px, py); ctx.stroke(); return null;
    },
    roundedRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height - radius); ctx.quadraticCurveTo(x, y + height, x + radius, y + height); ctx.lineTo(x + width - radius, y + height); ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); ctx.stroke(); return null; },
    bottomRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height - radius); ctx.quadraticCurveTo(x, y + height, x + radius, y + height); ctx.lineTo(x + width - radius, y + height); ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius); ctx.lineTo(x + width, y); ctx.lineTo(x, y); ctx.lineTo(x, y + radius); ctx.stroke(); return null; },
    rightRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + height); ctx.lineTo(x + width - radius, y + height); ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x, y); ctx.stroke(); return null; },
    leftRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height - radius); ctx.quadraticCurveTo(x, y + height, x + radius, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); ctx.stroke(); return null; },
    topRoundRect(ctx, x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x, y + radius); ctx.lineTo(x, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width, y + radius); ctx.quadraticCurveTo(x + width, y, x + width - radius, y); ctx.lineTo(x + radius, y); ctx.quadraticCurveTo(x, y, x, y + radius); ctx.stroke(); return null; },
  };
}()); function MF_Page() {
  const thisClass = this; this.NAME = 'Page'; this.x = 0; this.y = 0; this.transformLock = false; this.eid = ''; this.e2xml = new MF_ComponentXML(this); this.pageName = 'Page'; this.loaded = false; this.changed = false; this.assignedEvents = false; this.revisionChanged = false; this.duplicated = false; this.pagedata = null; this.width = 800; this.height = 600; this.noDBLoad = false; this.autoResize = true; this.comments = 0; this.rtcEditor = null; this.rtcEditorName = null; this.children = new ArrayCollection(); this.navHide = false; this.folder = false; this.parentPage = ''; this.layerLevel = -1; this.master = false; this.masterPage = ''; this.content = null; this.childComponents = new ArrayCollection(); this.stackOrder = new ArrayCollection(); this.selectors = new Object(); this.groupManager = new MF_GroupManager(this); this.undo = new Array(); this.redo = new Array(); this.highestWidth = 800; this.highestHeight = 600; this.lowestX = 0; this.lowestY = 0; this.cast = function (obj) { thisClass.pageName = obj.pageName; thisClass.eid = obj.eid; thisClass.parentPage = obj.parentPage; thisClass.folder = obj.folder; thisClass.master = obj.master; thisClass.masterPage = obj.masterPage; thisClass.navHide = obj.navHide; }; let thumbnailURL = ''; this.__defineGetter__('thumbnailURL', () => `https://s3.amazonaws.com/${MF_Global.getS3Bucket()}/app/wireframepro/company/${mf_main.editorController.projectObj.company}/projects/${mf_main.editorController.projectObj.id}/pages/${thisClass.eid}/image/thumb/${thisClass.eid}.png`); this.__defineSetter__('thumbnailURL', (val) => { thumbnailURL = val; }); let commentStr = ''; this.__defineGetter__('commentStr', () => { if (thisClass.comments < 10) { return thisClass.comments.toString(); } return '9+'; }); this.__defineSetter__('commentStr', (val) => { commentStr = val; }); this.closeRTCEditor = function () { thisClass.rtcEditor = null; thisClass.rtcEditorName = null; }; this.showRTCMsg = function () { if (thisClass.rtcEditor == null) { $('#mfRTCEditorLock').hide(); } else if (thisClass.eid == mf_main.editorController.page.eid && mf_main.editorController.EDITOR) { if (mf_main.editorController.EDITOR) { $('#mfRTCEditorLock').show(); if (thisClass.rtcEditor != null) { $('#mfRTCEditorImg').css('background-image', `url("${MF_Utils.get_gravatar(thisClass.rtcEditor, 32)}")`); }$('#mfRTCEditorMsg').text(`${thisClass.rtcEditorName} is now Editing this Page`); mf_main.editorController.rtcReSize(); } } }; this.createPageData = function () { thisClass.pagedata = new MF_PageData(); thisClass.pagedata.eid = thisClass.eid; thisClass.pagedata.name = thisClass.pageName; if (mf_main.editorController.projectObj) { thisClass.pagedata.projectid = mf_main.editorController.projectObj.id; thisClass.pagedata.clientid = mf_main.editorController.projectObj.company; } }; this.calculateDimensions = function () {
    let wid = 0; let hei = 0; let sx = 0; let sy = 0; thisClass.highestWidth = 0; thisClass.highestHeight = 0; thisClass.lowestX = 0; thisClass.lowestY = 0; let c1,
      c2,
      c3,
      c4 = {}; let bx1,
      by1,
      bx2,
      by2; let px,
      py; let tcount = 0; for (let i = 0; i < thisClass.childComponents.size(); i++) { const component = thisClass.childComponents.getItemAt(i); let dim = component; if (component.TRANSFORM) { dim = MF_Utils.calculateDimensions(component.startX, component.startY, component.endX, component.endY, component.delta); }wid = dim.width; hei = dim.height; sx = dim.x; sy = dim.y; if (!component.TRANSFORM && component.eangle != 0) { const deg = component.eangle; const ar = deg * Math.PI / 180; px = dim.x + dim.width * 0.5; py = dim.y + dim.height * 0.5; c1 = thisClass.getCorner(px, py, dim.x, dim.y, ar); c2 = thisClass.getCorner(px, py, dim.x + dim.width, dim.y, ar); c3 = thisClass.getCorner(px, py, dim.x + dim.width, dim.y + dim.height, ar); c4 = thisClass.getCorner(px, py, dim.x, dim.y + dim.height, ar); bx1 = Math.min(c1.x, c2.x, c3.x, c4.x); by1 = Math.min(c1.y, c2.y, c3.y, c4.y); bx2 = Math.max(c1.x, c2.x, c3.x, c4.x); by2 = Math.max(c1.y, c2.y, c3.y, c4.y); sx = bx1; sy = by1; wid = bx2 - bx1; hei = by2 - by1; } if ((sx + wid) > thisClass.highestWidth) { thisClass.highestWidth = sx + wid; } if ((sy + hei) > thisClass.highestHeight) { thisClass.highestHeight = sy + hei; } if (tcount == 0) { thisClass.lowestX = sx; thisClass.lowestY = sy; } else { if (sx < thisClass.lowestX) { thisClass.lowestX = sx; } if (sy < thisClass.lowestY) { thisClass.lowestY = sy; } }tcount++; } if (thisClass.lowestX > 10) { thisClass.lowestX -= 10; } if (thisClass.lowestY > 10) { thisClass.lowestY -= 10; }
  }; this.getCorner = function (pivotX, pivotY, cornerX, cornerY, angle) {
    let x,
      y,
      distance,
      diffX,
      diffY; diffX = cornerX - pivotX; diffY = cornerY - pivotY; distance = Math.sqrt(diffX * diffX + diffY * diffY); angle += Math.atan2(diffY, diffX); x = pivotX + distance * Math.cos(angle); y = pivotY + distance * Math.sin(angle); return { x, y };
  }; this.addComponent = function (component) { if (thisClass.layerLevel != -1) { thisClass.childComponents.addItemAt(component, thisClass.layerLevel); } else { thisClass.childComponents.addItem(component); } if (thisClass.layerLevel != -1) { this.stackOrder.addItemAt(component, thisClass.layerLevel); } else { this.stackOrder.addItem(component); }$(`#${component.eid}`).css('z-index', this.stackOrder.size()); }; this.clean = function () { $(`#mfPage${thisClass.eid}`).hide(); }; this.remove = function () { thisClass.loaded = false; thisClass.changed = false; thisClass.assignedEvents = false; thisClass.revisionChanged = false; thisClass.children = new ArrayCollection(); thisClass.childComponents = new ArrayCollection(); thisClass.stackOrder = new ArrayCollection(); thisClass.selectors = new Object(); thisClass.groupManager = new MF_GroupManager(this); thisClass.undo = new Array(); thisClass.redo = new Array(); $(`#mfPage${thisClass.eid}`).remove(); }; this.applySize = function () { if (thisClass.autoResize) { if ($('#mfEditorHolder').width() >= thisClass.width) { $('#mfEditorHolder').css('overflow-x', 'hidden'); $(`#mfPage${thisClass.eid}`).width('100%'); $('#mfContainerPage').width('100%'); } else { $('#mfEditorHolder').css('overflow-x', 'auto'); $(`#mfPage${thisClass.eid}`).width(thisClass.width); $('#mfContainerPage').width(thisClass.width); } if ($('#mfEditorHolder').height() >= thisClass.height) { $('#mfEditorHolder').css('overflow-y', 'hidden'); $(`#mfPage${thisClass.eid}`).height('100%'); $('#mfContainerPage').height('100%'); } else { $('#mfEditorHolder').css('overflow-y', 'auto'); $(`#mfPage${thisClass.eid}`).height(thisClass.height); $('#mfContainerPage').height(thisClass.height); } } else { $(`#mfPage${thisClass.eid}`).width(thisClass.width); $(`#mfPage${thisClass.eid}`).height(thisClass.height); $('#mfContainerPage').width($(`#mfPage${thisClass.eid}`).width()); $('#mfContainerPage').height($(`#mfPage${thisClass.eid}`).height()); } if (mf_main.RENDER && mf_main.REVISION == false) { $('#mfEditorHolder').css('overflow-x', 'hidden'); $('#mfEditorHolder').css('overflow-y', 'hidden'); } }; this.removeComponent = function (component) { const cmp = thisClass.getComponentByID(component); const cindx = thisClass.childComponents.getItemIndex(cmp); if (cindx != -1) { thisClass.childComponents.removeItemAt(cindx); } }; this.addGroupChildAt = function (select, pos) { const maxindex = mf_main.editorController.page.stackOrder.size() - 1; const maxCindex = mf_main.editorController.page.childComponents.size() - 1; frontindex = mf_main.editorController.page.stackOrder.getItemIndex(select); ind = mf_main.editorController.page.childComponents.getItemIndex(select.component); let count = 2; for (let j = frontindex - 1; j < maxindex - 1; j++) { const existingSelect = mf_main.editorController.page.stackOrder.getItemAt(j + 2); mf_main.editorController.page.stackOrder.setItemAt(existingSelect, j); count++; }mf_main.editorController.page.stackOrder.setItemAt(select, maxindex); mf_main.editorController.page.stackOrder.setItemAt(select.component, maxindex - 1); count = 0; for (let k = ind; k < maxCindex; k++) { const existingComp = mf_main.editorController.page.childComponents.getItemAt(k + 1); mf_main.editorController.page.childComponents.setItemAt(existingComp, k); count++; }mf_main.editorController.page.childComponents.setItemAt(select.component, maxCindex); }; this.getComponentByID = function (id) { for (let i = 0; i < thisClass.childComponents.size(); i++) { const component = thisClass.childComponents.getItemAt(i); if (component.eid == id) { return component; } } return null; }; this.addSelector = function (selector) { thisClass.selectors[selector.id] = selector; }; this.getSelector = function (sid) { return thisClass.selectors[sid]; };
} var MF_PagePool = (function () {
  let pages = new ArrayCollection(); let pageMapCollection = new ArrayCollection(); let pageMap = new Object(); let revPageMap = new Object(); let hierarchyData = new Array(); function privateMethod() {} return {
    addNewPage(pageName, copyPage) { const page = new MF_Page(); page.eid = mf_main.editorController.guidGenerator(); let num = MF_PagePool.getPages().size(); num += 1; if (pageName == null || pageName == '') { page.pageName = `Page ${num.toString()}`; } else { page.pageName = pageName; }page.parentPage = ''; page.folder = false; page.createPageData(); page.e2xml.applySettings(); page.changed = true; MF_PagePool.addPage(page); return page; }, addNewFolder(pageName) { const page = new MF_Page(); page.eid = mf_main.editorController.guidGenerator(); page.createPageData(); let num = MF_PagePool.getPages().size(); num += 1; if (pageName == null || pageName == '') { page.pageName = `Folder ${num.toString()}`; } else { page.pageName = pageName; }page.e2xml.applySettings(); page.changed = true; page.folder = true; MF_PagePool.addPage(page); return page; }, addPage(page) { MF_PagePool.getPages().addItem(page); return null; }, clean(page) { pages = new ArrayCollection(); pageMap = new Object(); revPageMap = new Object(); hierarchyData = new Array(); pageMapCollection = new ArrayCollection(); return null; }, setPages(newcollection) { pages = newcollection; return null; }, mapPages() { pageMap = new Object(); revPageMap = new Object(); hierarchyData = new Array(); pageMapCollection = new ArrayCollection(); const tempPages = new Object(); for (let j = 0; j < MF_PagePool.getPages().size(); j++) { var page = MF_PagePool.getPages().getItemAt(j); pageMap[page.eid] = `p${j}`; revPageMap[`p${j}`] = page.eid; tempPages[page.eid] = page; page.children = new ArrayCollection(); } for (let i = 0; i < MF_PagePool.getPages().size(); i++) { var page = MF_PagePool.getPages().getItemAt(i); if (pageMap[page.parentPage]) { const parentPage = tempPages[page.parentPage]; if (parentPage && parentPage.parentPage != page.eid) { parentPage.children.addItem(page); } else { page.parentPage = ''; pageMapCollection.addItem(page); } } else { pageMapCollection.addItem(page); } } if (pageMapCollection.size() > 0) { hierarchyData = formSiteMap(pageMapCollection, hierarchyData); } return hierarchyData; }, getPageMapCollection() { return pageMapCollection; }, getPageMap() { return pageMap; }, getRevPageMap() { return revPageMap; }, getMap() { return hierarchyData; }, deletePage(delpage) { for (var k = 0; k < delpage.children.length; k++) { const litem = delpage.children[k]; litem.parentPage = delpage.parentPage; }$(`#mfPage${delpage.eid}`).remove(); for (var k = 0; k < MF_PagePool.getPages().size(); k++) { const mpage = MF_PagePool.getPages().data[k]; if (mpage.eid != delpage.eid) { if (mpage.masterPage == delpage.eid) { mpage.masterPage = ''; } } } const pagedelindx = (MF_PagePool.getPages().getItemIndex(delpage)); if (pagedelindx != -1) { MF_PagePool.getPages().removeItemAt(pagedelindx); } return null; }, getPages() { return pages; }, changeList(newlist) { pages = newlist; return null; }, getPage(eid) { for (let i = 0; i < pages.size(); i++) { const page = pages.getItemAt(i); if (page.eid == eid) { return page; } } return null; },
  };
}()); function formSiteMap(pages, arr) { for (let i = 0; i < pages.size(); i++) { const page = pages.getItemAt(i); const obj = new Object(); obj.id = page.eid; obj.items = new Array(); obj.text = page.pageName; obj.parentid = MF_PagePool.getPageMap()[page.parentPage]; if (page.folder) { obj.imageUrl = 'images/editor/folder.png'; } else if (page.navHide) { obj.imageUrl = 'images/editor/pagehide.png'; } else { obj.imageUrl = 'images/editor/page.png'; }arr.push(obj); if (page.children.size() > 0) { formSiteMap(page.children, obj.items); } } return arr; } var MF_IDManager = (function () { function privateMethod() {} return { generateComponentID(page, component) { const name = component.NAME; const uid = mf_main.editorController.guidGenerator(); component.eid = uid; return component.eid; }, deleteID(page, id) { page.removeComponent(id); return null; }, IsIDGood(page, id) { if (page.getComponentByID(id) == null) { return true; } return false; } }; }()); function MF_ComponentSettings(component) { this.propertiesXML = new Object(); this.properties = new Array(); this.component = component; const thisClass = this; this.getXML = function () { let xmlString = '<settings>'; for (const prop in this.propertiesXML) { if (prop != 'ecoordinates' && prop != 'esize' && prop != 'eangle' && prop != 'transformLock') { if ((prop == 'link' || prop == 'pageSetLink' || prop == 'linkArray') && mf_main.editorController.exportMode) {} else { xmlString += (this.propertiesXML[prop]); } } }xmlString += '</settings>'; return xmlString; }; this.typeConverter = function (val, type) { let newval; if (type == 'Number') { newval = parseFloat(val); } if (type == 'String') { newval = String(val); } if (type == 'uint') { newval = parseInt(val); } if (type == 'Boolean') { if (val == 'true') { newval = true; } if (val == 'false') { newval = false; } } return newval; }; this.setProperty = function (pname, pval, ptype, pxml) { this.propertiesXML[pname] = pxml; this.properties[pname] = pval; thisClass.component[pname] = pval; }; this.getProperty = function (pname) { return this.properties[pname]; }; } function MF_ComponentXML(component) { this.settingsXML = $(); this.component = component; this.settings = new MF_ComponentSettings(); this.settings.component = component; const thisClass = this; this.getComponent = function () { return this.component; }; this.formXML = function (nodata) { const xmlString = this.formComponentXML(this.component, nodata); const outerHtml = $('<div/>').append(xmlString).html(); this.settingsXML = $(outerHtml); return this.settingsXML; }; this.formComponentXML = function (component, nodata) { let xmlString; const typename = component.NAME; if (typename == 'Page') { const eid = ` eid="${component.eid}" `; const pageName = ` pageName="${component.pageName}" `; if (component.masterPage == null) { component.masterPage = ''; } const masterPage = ` masterPage="${component.masterPage}" `; const dimensions = ` w="${component.width}"  h="${component.height}"  autoResize="${component.autoResize.toString()}" `; let folder = component.folder; if (folder == null) { folder = 'false'; } const folderTxt = ` folder="${folder}" `; const navHideTxt = ` navHide="${component.navHide.toString()}" `; const master = ''; xmlString = `<component type="${typename}" ${eid}${dimensions}${folderTxt}${navHideTxt}${masterPage}${master} >`; xmlString += component.e2xml.settings.getXML(); } else { let locked = ''; if (component.transformLock) { locked = 'locked="true"'; } let wei = component.width; let hei = component.height; const nx = component.x; const ny = component.y; let groupID = ''; if (component.GROUPID != '') { groupID = `groupID="${component.GROUPID}"`; } if (component.AUTO_SIZE) { wei = component.mwidth; hei = component.mheight; } let ecoord = `x="${nx}" y="${ny}" `; if (component.TRANSFORM) { ecoord = `startX="${component.startX}" startY="${component.startY}" endX="${component.endX}" endY="${component.endY}" `; }xmlString = `<component type="${typename}" angle="${component.eangle.toString()}" w="${wei}" h="${hei}"${ecoord} ${locked} ${groupID} >`; xmlString += component.e2xml.settings.getXML(); } if (component.NAME == 'Page' && nodata != 'true') { xmlString += component.groupManager.getLockedGroups(); xmlString += component.groupManager.getLinkedGroups(); xmlString += '<children>'; for (let i = 0; i < component.childComponents.size(); i++) { const childComponent = component.childComponents.getItemAt(i); xmlString += thisClass.formComponentXML(childComponent); }xmlString += '</children>'; }xmlString += '</component>'; return xmlString; }; this.applySettings = function () { try { if (this.component.NAME == 'Page') {} else { const w = Number(this.settingsXML.attr('w')); const h = Number(this.settingsXML.attr('h')); const x = Number(this.settingsXML.attr('x')); const y = Number(this.settingsXML.attr('y')); if (this.component.TRANSFORM) { const startX = Number(this.settingsXML.attr('startX')); const startY = Number(this.settingsXML.attr('startY')); const endX = Number(this.settingsXML.attr('endX')); const endY = Number(this.settingsXML.attr('endY')); var posObject = new Object(); posObject.startX = startX; posObject.startY = startY; posObject.endX = endX; posObject.endY = endY; this.addPropObject('ecoordinates', posObject, 'default'); } else { var posObject = new Object(); posObject.x = x; posObject.y = y; this.addPropObject('ecoordinates', posObject, 'default'); } const angle = Number(this.settingsXML.attr('angle')); if (this.settingsXML.attr('locked') != null) { const lock = this.settingsXML.attr('locked'); if (lock == 'true') { this.component.transformLock = true; } } const sizeObject = new Object(); sizeObject.width = w; sizeObject.height = h; this.addPropObject('esize', sizeObject, 'default'); this.addPropSingle('eangle', angle, 'default'); } const thisClass = this; $(this.settingsXML).find('settings').each(function () { if (thisClass.component.NAME != 'Page') { thisClass.applyComponentSettings($(this)); } }); } catch (err) {} }; this.applyComponentSettings = function (dataxml) { try { let editValue = ''; let editPresent = false; const thisClass = this; $(dataxml).find('property').each(function () { const propItem = $(this); const propName = propItem.attr('name'); const propType = propItem.attr('type'); let propValue = propItem.text(); if (propName == 'text') { propValue = propItem.html(); } if (propName == 'content' && thisClass.component.NAME == 'MF_HTMLEmbed') { propValue = MF_Utils.htmlEncode(propValue); } if (propType == 'Object') { const obj = thisClass.decodeObjectXML(propItem.find('object')); thisClass.addPropObject(propName, obj, 'default'); } else if (propType == 'Array') { const arr = new Array(); const arrType = propItem.find('array').attr('type'); if (arrType == 'Object') { $(propItem.find('array')).find('object').each(function () { arr[arr.length] = (thisClass.decodeObjectXML($(this))); }); } else { $(propItem.find('array')).find('val').each(function () { arr[arr.length] = (thisClass.setType(arrType, $(this)['0'].textContent)); }); }thisClass.addPropArray(propName, arr, arrType, 'default'); } else if (propName != 'editValue') { thisClass.addPropSingle(propName, thisClass.setType(propType, propValue), 'default'); } else { editPresent = true; editValue = thisClass.setType(propType, propValue); } }); if (editPresent) { thisClass.addPropSingle('editValue', editValue, 'default'); } } catch (err) { alert(err); } }; this.decodeObjectXML = function (xml) { const thisClass = this; let obj = new Object(); let pcount = 0; $(xml).find('prop').each(function () { const p = $(this).attr('name'); const type = $(this).attr('type'); obj[p] = thisClass.setType(type, $(this).text()); pcount++; }); if (pcount == 0) { obj = null; } return obj; }; this.setType = function (type, val) { if (type == 'Number') { return parseFloat(val); } if (type == 'int') { return parseInt(val); } if (type == 'Boolean') { if (val == 'true') { return true; } return false; } return val; }; this.getType = function (val) { let type = 'String'; if (typeof (val) === 'int') { type = 'int'; } if (typeof (val) === 'number') { type = 'Number'; } if (typeof (val) === 'boolean') { type = 'Boolean'; } return type; }; this.addPropSingle = function (propName, propValue, bUndo) { bUndo = typeof (bUndo) !== 'undefined' ? bUndo : 'true'; if (thisClass.component.GENONLY) { bUndo = 'default'; } if (bUndo != 'default') { const undoObj = new MF_UndoDAO(); undoObj.propSingleUndo(thisClass.component, propName, thisClass.component[propName]); thisClass.undoManager(bUndo, undoObj); } const propType = this.getType(propValue); const propXMLText = `<property name="${propName}" type="${propType}">${propValue}</property>`; const propXML = propXMLText; this.settings.setProperty(propName, propValue, propType, propXML); if (propName == 'eangle') { const selector = thisClass.component.selector; if (selector) { selector.angle = propValue; selector.setAngle(false, true, false); } } }; this.addPropObject = function (propName, propValue, bUndo) { bUndo = typeof (bUndo) !== 'undefined' ? bUndo : 'true'; if (thisClass.component.GENONLY) { bUndo = 'default'; } if (bUndo != 'default') { const undoObj = new MF_UndoDAO(); undoObj.propObjectUndo(thisClass.component, propName, thisClass.component[propName]); thisClass.undoManager(bUndo, undoObj); } const objXML = this.encodeObjectXML(propValue); const propType = 'Object'; const propXMLText = `<property name="${propName}" type="${propType}">${objXML}</property>`; const propXML = propXMLText; this.settings.setProperty(propName, propValue, propType, propXML); if (propName == 'ecoordinates' || propName == 'esize') { if (propName == 'ecoordinates') { if (thisClass.component.TRANSFORM) { thisClass.component.startX = propValue.startX; thisClass.component.startY = propValue.startY; thisClass.component.endX = propValue.endX; thisClass.component.endY = propValue.endY; } else { thisClass.component.x = propValue.x; thisClass.component.y = propValue.y; } } if (propName == 'esize') { if (!thisClass.component.AUTOSIZE) { thisClass.component.width = propValue.width; thisClass.component.height = propValue.height; } } const selector = thisClass.component.selector; if (selector) { selector.x = thisClass.component.x - 5; selector.y = thisClass.component.y - 5; if (!thisClass.component.AUTOSIZE) { selector.width = thisClass.component.width + 10; selector.height = thisClass.component.height + 10; } } } else {} }; this.addPropArray = function (propName, propValue, arrayType, bUndo) { bUndo = typeof (bUndo) !== 'undefined' ? bUndo : 'true'; if (thisClass.component.GENONLY) { bUndo = 'default'; } if (bUndo != 'default') { const undoObj = new MF_UndoDAO(); undoObj.propArrayUndo(thisClass.component, propName, thisClass.component[propName], arrayType); thisClass.undoManager(bUndo, undoObj); } const propType = 'Array'; let arrXML = `<array type="${arrayType}">`; if (arrayType == 'Object') { for (var i = 0; i < propValue.length; i++) { const objval = propValue[i]; arrXML += thisClass.encodeObjectXML(objval); } } else { for (var i = 0; i < propValue.length; i++) { const val = propValue[i]; arrXML = `${arrXML}<val>${val}</val>`; } }arrXML += '</array>'; const propXMLText = `<property name="${propName}" type="${propType}">${arrXML}</property>`; const propXML = propXMLText; this.settings.setProperty(propName, propValue, propType, propXML); }; this.encodeObjectXML = function (obj) { let objXML = '<object>'; for (const p in obj) { const ptype = this.getType(obj[p]); objXML = `${objXML}<prop type="${ptype}" name="${p}">${obj[p]}</prop>`; }objXML += '</object>'; return objXML; }; } function MF_GroupManager(caller) { const thisClass = this; this.callerPage = caller; this.groups = new Object(); this.groupSelectors = new Object(); this.lockedGroups = new Object(); this.linkedGroups = new Object(); this.getLockedGroups = function () { let count = 0; let lockXML = '<lockedGroups>'; for (const gid in this.lockedGroups) { count++; if (this.groups[gid]) { lockXML = `${lockXML}<gid>${gid}</gid>`; } }lockXML += '</lockedGroups>'; if (count > 0) { return lockXML; } return ''; }; this.getLinkedGroups = function () { let count = 0; let linkXML = '<linkedGroups>'; for (const gid in this.linkedGroups) { count++; if (this.groups[gid]) { linkXML = `${linkXML}<linkgid group='${gid}' >${this.linkedGroups[gid].link}</linkgid>`; } }linkXML += '</linkedGroups>'; if (count > 0) { return linkXML; } return ''; }; this.loadLockedGroups = function (xml) { if (xml) { $(xml).find('gid').each(function () { const propItem = $(this); const gid = propItem.text(); if (gid != '') { thisClass.lockGroup(gid); } }); } }; this.loadLinkedGroups = function (xml) { if (xml) { $(xml).find('linkgid').each(function () { const propItem = $(this); const gid = propItem.attr('group'); const linkObj = new Object(); linkObj.link = propItem.text(); linkObj.GROUP = true; linkObj.GROUPID = gid; thisClass.linkedGroups[gid] = linkObj; }); } }; this.addGroup = function (gid, comp) { comp.GROUPID = gid; let collection = thisClass.groups[gid]; if (collection) { collection.addItem(comp); } else { collection = new ArrayCollection(); collection.addItem(comp); thisClass.groups[gid] = collection; } }; this.lockGroup = function (gid) { if (thisClass.groups[gid]) { thisClass.lockedGroups[gid] = true; const groupselect = thisClass.groupSelectors[gid]; if (groupselect) { groupselect.setLocking(true); } } }; this.unLockGroup = function (gid) { if (thisClass.lockedGroups[gid]) { delete thisClass.lockedGroups[gid]; const groupselect = thisClass.groupSelectors[gid]; if (groupselect) { groupselect.setLocking(false); } } }; this.unLockAllGroups = function () { for (const gid in thisClass.lockedGroups) { delete thisClass.lockedGroups[gid]; const groupselect = thisClass.groupSelectors[gid]; if (groupselect) { groupselect.setLocking(false); } } }; this.addAll = function () { for (const gid in thisClass.groups) { thisClass.addGroupSelector(gid); } }; this.resetSelector = function (gid) { try { const groupselect = this.groupSelectors[gid]; if (groupselect) { let selcounter = 0; let minX = 0; let minY = 0; let maxX = 0; let maxY = 0; let pos = 0; for (const selectid in groupselect.globalselects) { const select = groupselect.globalselects[selectid]; const comp = select.component; selcounter++; const selwidth = select.width; const selheight = select.height; const ssindx = mf_main.editorController.page.stackOrder.getItemIndex(select); if (ssindx != -1) { const ind = ssindx; if (ind > pos) { pos = ind; } } if (selcounter == 1) { minX = select.x; minY = select.y; maxX = select.x + selwidth; maxY = select.y + selheight; } else { if (select.x < minX) { minX = select.x; } if (select.y < minY) { minY = select.y; } if ((select.x + selwidth) > maxX) { maxX = select.x + selwidth; } if ((select.y + selheight) > maxY) { maxY = select.y + selheight; } } }groupselect.x = minX; groupselect.y = minY; groupselect.origX = minX; groupselect.origY = minY; groupselect.width = maxX - minX; groupselect.height = maxY - minY; groupselect.POS = pos; groupselect.render(false); if ((pos + 1) <= (mf_main.editorController.page.stackOrder.size())) { $(`#${groupselect.id}`).css('z-index', pos + 1); } else { $(`#${groupselect.id}`).css('z-index', mf_main.editorController.page.stackOrder.size() + 1); } } } catch (e) { console.log(e); } }; this.addGroupSelector = function (gid) { let selcounter = 0; let minX = 0; let minY = 0; let maxX = 0; let maxY = 0; let pos = 0; const groupselect = new MF_Selector(); groupselect.GLOBAL_SELECT = true; groupselect.GROUPID = gid; groupselect.GROUP = true; groupselect.globalselects = new Object(); const coll = thisClass.getGroupComponents(gid); for (let k = 0; k < coll.size(); k++) { const comp = coll.getItemAt(k); const select = comp.selector; selcounter++; groupselect.globalselects[select.id] = select; const selwidth = select.width; const selheight = select.height; const ind = mf_main.editorController.page.stackOrder.getItemIndex(select); if (ind > pos) { pos = ind; } if (selcounter == 1) { minX = select.x; minY = select.y; maxX = select.x + selwidth; maxY = select.y + selheight; } else { if (select.x < minX) { minX = select.x; } if (select.y < minY) { minY = select.y; } if ((select.x + selwidth) > maxX) { maxX = select.x + selwidth; } if ((select.y + selheight) > maxY) { maxY = select.y + selheight; } } }groupselect.x = minX; groupselect.y = minY; groupselect.origX = minX; groupselect.origY = minY; groupselect.width = maxX - minX; groupselect.height = maxY - minY; if (this.lockedGroups[gid]) { groupselect.setLocking(true); }groupselect.POS = pos; groupselect.id = `${groupselect.GROUPID}_${thisClass.callerPage.eid}`; groupselect.render(); if ((pos + 1) <= (mf_main.editorController.page.stackOrder.size())) { $(`#${groupselect.id}`).css('z-index', pos + 1); } else { $(`#${groupselect.id}`).css('z-index', mf_main.editorController.page.stackOrder.size() + 1); }thisClass.groupSelectors[groupselect.GROUPID] = groupselect; mf_main.editorController.selectorEvents(groupselect); return groupselect; }; this.getGroupComponents = function (gid) { return thisClass.groups[gid]; }; this.clearGroupSelectorByID = function (gid) { if (mf_main.editorController.currentGroupEdit) { return; } const selector = thisClass.groupSelectors[gid]; delete thisClass.groupSelectors[gid]; const collection = thisClass.groups[gid]; for (let k = 0; k < collection.size(); k++) { const comp = collection.getItemAt(k); comp.GROUPID = ''; } delete thisClass.groups[gid]; delete thisClass.lockedGroups[gid]; if (selector) { const sindx = mf_main.editorController.page.stackOrder.getItemIndex(selector); if (sindx != -1) { mf_main.editorController.page.stackOrder.removeItemAt(sindx); }$(`#${selector.id}`).remove(); } delete thisClass.groupSelectors[gid]; delete thisClass.groups[gid]; delete thisClass.lockedGroups[gid]; delete thisClass.linkedGroups[gid]; }; this.removeGroupComponent = function (gid, comp) { const collection = thisClass.groups[gid]; if (collection && collection.getItemIndex(comp) != -1) { collection.removeItemAt(collection.getItemIndex(comp)); } const groupselect = this.groupSelectors[gid]; if (groupselect) { if (comp.selector) { delete groupselect.globalselects[comp.selector.id]; } } }; this.clear = function () { this.groups = new Object(); this.groupSelectors = new Object(); this.lockedGroups = new Object(); this.linkedGroups = new Object(); }; } var MF_ComponentSettingUtils = (function () {
  function privateMethod() {} return {
    rememberToggle(refClass) { if (mf_main.editorController.rememberToggleSettings[refClass.NAME]) { if (mf_main.editorController.rememberToggleSettings[refClass.NAME] == 'hide') { MF_ComponentSettingUtils.hideSettings(refClass); } else { MF_ComponentSettingUtils.showSettings(refClass); } } },
    showSettings(refClass) { refClass.showSetting = true; $(`#${refClass.eid}_partSetting`).show(); $(`#${refClass.eid}_settingToggleHide`).hide(); $(`#${refClass.eid}_settingToggleShow`).show(); },
    hideSettings(refClass) { refClass.showSetting = false; $(`#${refClass.eid}_partSetting`).hide(); $(`#${refClass.eid}_settingToggleHide`).show(); $(`#${refClass.eid}_settingToggleShow`).hide(); },
    setupToggle(refClass) { $(`#${refClass.eid}_settingToggle`).click((event) => { if (refClass.showSetting) { refClass.showSetting = false; $(`#${refClass.eid}_partSetting`).hide(); $(`#${refClass.eid}_settingToggleHide`).show(); $(`#${refClass.eid}_settingToggleShow`).hide(); mf_main.editorController.rememberToggleSettings[refClass.NAME] = 'hide'; } else { refClass.showSetting = true; $(`#${refClass.eid}_partSetting`).show(); $(`#${refClass.eid}_settingToggleHide`).hide(); $(`#${refClass.eid}_settingToggleShow`).show(); mf_main.editorController.rememberToggleSettings[refClass.NAME] = 'show'; } }); },
    setupTransform(refClass) {
      $(`#rotate_${refClass.eid}`).focusin(() => { mf_main.editorController.disableShortcuts(); }); $(`#rotate_${refClass.eid}`).focusout(() => { mf_main.editorController.enableShortcuts(); }); $(`#rotate_${refClass.eid}`).kendoNumericTextBox({
        format: '#', spinners: true, change: onRotateChange, spin: onRotateChange, decimals: 0,
      }); function onRotateChange() { const angle = this.value(); if (refClass.settingsHolder.component) { refClass.angle = angle; refClass.settingsHolder.component.e2xml.addPropSingle('eangle', refClass.angle); refClass.settingsHolder.component.render(false); mf_main.editorController.addSelectorResize(refClass.settingsHolder.component.selector); } }refClass.rotatebox = $(`#rotate_${refClass.eid}`).data('kendoNumericTextBox'); $(`#x_${refClass.eid}`).focusin(() => { mf_main.editorController.disableShortcuts(); }); $(`#x_${refClass.eid}`).focusout(() => { mf_main.editorController.enableShortcuts(); }); $(`#x_${refClass.eid}`).kendoNumericTextBox({
        format: '#', spinners: true, change: onXChange, spin: onXChange, decimals: 0,
      }); function onXChange() { const x = this.value(); if (refClass.settingsHolder.component) { const posObject = new Object(); posObject.y = refClass.settingsHolder.component.ecoordinates.y; posObject.x = x; refClass.settingsHolder.component.e2xml.addPropObject('ecoordinates', posObject); refClass.settingsHolder.component.render(false); mf_main.editorController.addSelectorResize(refClass.settingsHolder.component.selector); } else { refClass.settingsHolder.selector.origH = refClass.settingsHolder.selector.height; refClass.settingsHolder.selector.origW = refClass.settingsHolder.selector.width; refClass.settingsHolder.selector.x = x; refClass.settingsHolder.selector.render(false); $(`#${refClass.settingsHolder.selector.id}`).css('left', refClass.settingsHolder.selector.x); $(`#${refClass.settingsHolder.selector.id}`).css('top', refClass.settingsHolder.selector.y); mf_main.editorController.globalSelectorMove(refClass.settingsHolder.selector); if (mf_main.editorController.selectorResize) { $(`#${mf_main.editorController.selectorResize.id}`).css('left', refClass.settingsHolder.selector.x); $(`#${mf_main.editorController.selectorResize.id}`).css('top', refClass.settingsHolder.selector.y); } }mf_main.editorController.resizePage(); }refClass.xbox = $(`#x_${refClass.eid}`).data('kendoNumericTextBox'); $(`#y_${refClass.eid}`).focusin(() => { mf_main.editorController.disableShortcuts(); }); $(`#y_${refClass.eid}`).focusout(() => { mf_main.editorController.enableShortcuts(); }); $(`#y_${refClass.eid}`).kendoNumericTextBox({
        format: '#', spinners: true, change: onYChange, spin: onYChange, decimals: 0,
      }); function onYChange() { const y = this.value(); if (refClass.settingsHolder.component) { const posObject = new Object(); posObject.x = refClass.settingsHolder.component.ecoordinates.x; posObject.y = y; refClass.settingsHolder.component.e2xml.addPropObject('ecoordinates', posObject); refClass.settingsHolder.component.render(false); mf_main.editorController.addSelectorResize(refClass.settingsHolder.component.selector); } else { refClass.settingsHolder.selector.origH = refClass.settingsHolder.selector.height; refClass.settingsHolder.selector.origW = refClass.settingsHolder.selector.width; refClass.settingsHolder.selector.y = y; refClass.settingsHolder.selector.render(false); $(`#${refClass.settingsHolder.selector.id}`).css('left', refClass.settingsHolder.selector.x); $(`#${refClass.settingsHolder.selector.id}`).css('top', refClass.settingsHolder.selector.y); mf_main.editorController.globalSelectorMove(refClass.settingsHolder.selector); if (mf_main.editorController.selectorResize) { $(`#${mf_main.editorController.selectorResize.id}`).css('left', refClass.settingsHolder.selector.x); $(`#${mf_main.editorController.selectorResize.id}`).css('top', refClass.settingsHolder.selector.y); } }mf_main.editorController.resizePage(); }refClass.ybox = $(`#y_${refClass.eid}`).data('kendoNumericTextBox'); $(`#w_${refClass.eid}`).focusin(() => { mf_main.editorController.disableShortcuts(); }); $(`#w_${refClass.eid}`).focusout(() => { mf_main.editorController.enableShortcuts(); }); $(`#w_${refClass.eid}`).kendoNumericTextBox({
        format: '#', spinners: true, change: onWChange, spin: onWChange, decimals: 0,
      }); function onWChange() { const w = this.value(); if (refClass.settingsHolder.component) { const sizeUI = new Object(); sizeUI.height = refClass.settingsHolder.component.height; sizeUI.width = w; refClass.settingsHolder.component.e2xml.addPropObject('esize', sizeUI); refClass.settingsHolder.component.render(false); mf_main.editorController.addSelectorResize(refClass.settingsHolder.component.selector); } else { refClass.settingsHolder.selector.origH = refClass.settingsHolder.selector.height; refClass.settingsHolder.selector.origW = refClass.settingsHolder.selector.width; refClass.settingsHolder.selector.width = w; refClass.settingsHolder.selector.render(false); refClass.settingsHolder.selector.setSize(); }mf_main.editorController.resizePage(); }refClass.wbox = $(`#w_${refClass.eid}`).data('kendoNumericTextBox'); $(`#h_${refClass.eid}`).kendoNumericTextBox({
        format: '#', spinners: true, change: onHChange, spin: onHChange, decimals: 0,
      }); $(`#h_${refClass.eid}`).focusin(() => { mf_main.editorController.disableShortcuts(); }); $(`#h_${refClass.eid}`).focusout(() => { mf_main.editorController.enableShortcuts(); }); function onHChange() { const h = this.value(); if (refClass.settingsHolder.component) { const sizeUI = new Object(); sizeUI.height = h; sizeUI.width = refClass.settingsHolder.component.width; refClass.settingsHolder.component.e2xml.addPropObject('esize', sizeUI); refClass.settingsHolder.component.render(false); mf_main.editorController.addSelectorResize(refClass.settingsHolder.component.selector); } else { refClass.settingsHolder.selector.origH = refClass.settingsHolder.selector.height; refClass.settingsHolder.selector.origW = refClass.settingsHolder.selector.width; refClass.settingsHolder.selector.height = h; refClass.settingsHolder.selector.render(false); refClass.settingsHolder.selector.setSize(); }mf_main.editorController.resizePage(); }refClass.hbox = $(`#h_${refClass.eid}`).data('kendoNumericTextBox'); if (refClass.settingsHolder.component) { refClass.xbox.value(refClass.settingsHolder.component.ecoordinates.x); refClass.ybox.value(refClass.settingsHolder.component.ecoordinates.y); refClass.wbox.value(refClass.settingsHolder.component.esize.width); refClass.hbox.value(refClass.settingsHolder.component.esize.height); refClass.rotatebox.value(refClass.angle); } else { refClass.xbox.value(refClass.settingsHolder.selector.x); refClass.ybox.value(refClass.settingsHolder.selector.y); refClass.wbox.value(refClass.settingsHolder.selector.width); refClass.hbox.value(refClass.settingsHolder.selector.height); }
    },
    updateTransform(xbox, ybox, wbox, hbox, rotatebox, selector) { if (xbox != null) { xbox.value(selector.x); } if (ybox != null) { ybox.value(selector.y); } if (wbox != null) { wbox.value(selector.width); } if (hbox != null) { hbox.value(selector.height); } if (selector.component) { if (rotatebox != null) { rotatebox.value(selector.angle); } } },
    setDragEvents(settingsClass) { $(`#${settingsClass.eid}`).drag('start', (ev, dd) => { ev.stopImmediatePropagation(); }); $(`#${settingsClass.eid}`).drag(function (ev, dd) { ev.stopImmediatePropagation(); const props = {}; props.top = dd.offsetY; props.left = dd.offsetX; mf_main.editorController.settingPosX = props.left; mf_main.editorController.settingPosY = props.top; $(this).css(props); }); $(`#${settingsClass.eid}`).drag('end', (ev, dd) => { ev.stopImmediatePropagation(); mf_main.editorController.settingManualPlace = true; }); },
    setCommonDragEvents(eid) { $(`#${eid}`).drag('start', (ev, dd) => { ev.stopImmediatePropagation(); }); $(`#${eid}`).drag(function (ev, dd) { ev.stopImmediatePropagation(); const props = {}; props.top = dd.offsetY; props.left = dd.offsetX; $(this).css(props); }); $(`#${eid}`).drag('end', (ev, dd) => { ev.stopImmediatePropagation(); }); },
    setLinkType(lid, component) { MF_ComponentSettingUtils.convert2LinkObj(component); if (component.link != '') { if (component.linkObj.type == 'web') { $(lid).text(`${component.linkObj.url}`); } else { let res = 'Select Page'; for (let k = 0; k < MF_PagePool.getPages().size(); k++) { const litem = MF_PagePool.getPages().getItemAt(k); if (litem.eid == component.linkObj.url) { res = litem.pageName; break; } } if (res == 'Select Page') { if (component.linkObj.url == '_Next_') { res = 'Next Page'; } if (component.linkObj.url == '_Prev_') { res = 'Previous Page'; } if (component.linkObj.url == '_First_') { res = 'First Page'; } if (component.linkObj.url == '_Last_') { res = 'Last Page'; } }$(lid).text(res); } } else { $(lid).text('Select Page'); } },
    openLinkModal(lid, holder) { mf_main.editorController.pageLinkController.currentLinkID = lid; if (holder.settingsHolder.component) { mf_main.editorController.pageLinkController.component = holder.settingsHolder.component; } else { mf_main.editorController.pageLinkController.component = holder.linkObj; }mf_main.editorController.pageLinkController.openPageLinkDialog(); },
    openMultiLinkModal(lid, holder) { mf_main.editorController.pageMultiLinkController.currentLinkID = lid; mf_main.editorController.pageMultiLinkController.component = holder.settingsHolder.component; mf_main.editorController.pageMultiLinkController.openPageLinkDialog(); },
    openMultiIconModal(lid, holder) { mf_main.editorController.iconAssignController.currentIconID = lid; mf_main.editorController.iconAssignController.component = holder.settingsHolder.component; mf_main.editorController.iconAssignController.openPageIconDialog(); },
    openSingleIconModal(lid, holder) { mf_main.editorController.iconAssignController.currentIconID = lid; if (holder.settingsHolder) { mf_main.editorController.iconAssignController.component = holder.settingsHolder.component; } else { mf_main.editorController.iconAssignController.component = holder.component; }mf_main.editorController.iconAssignController.settingsObj = holder; mf_main.editorController.iconAssignController.openSingleIconDialog(); },
    convert2LinkObj(component) { if (component.link != '' && component.link != null) { const linkarr = component.link.split(':--:'); if (linkarr.length == 3) { component.linkObj = new MF_LinkObj(); component.linkObj.event = linkarr[0]; if (linkarr[1] == 'page') { component.linkObj.type = 'page'; const page = MF_PagePool.getPage(linkarr[2]); if (page) { component.linkObj.url = page.eid; component.linkObj.pageName = page.pageName; } } if (linkarr[1] == 'web') { component.linkObj.type = 'web'; component.linkObj.url = linkarr[2]; } } } else { component.linkObj = null; } },
    getMultiLinkHighlightObj(component, arr) { let linkcount = 0; let linkSelectObj = null; if (mf_main.editorController.VIEWER && component.pageSetLink) { for (let n = 0; n < arr.length; n++) { const obj = MF_ComponentSettingUtils.highlightMultiLink(component, linkcount, n); if (obj.select) { linkSelectObj = obj; }linkcount = obj.linkcount; } } return linkSelectObj; },
    highlightMultiLink(component, linkcount, i) { const obj = new Object(); obj.highlightItem = true; obj.select = false; obj.linkcount = linkcount; if (mf_main.editorController.VIEWER && component.pageSetLink) { let highlightPass = false; if (component.showDivider) { if (i % 2 == 0) { highlightPass = true; } } else { highlightPass = true; } if (highlightPass) { if (component && component.linkArray) { const plink = component.linkArray[obj.linkcount]; if (plink) { const plinkarr = plink.split(':--:'); if (plinkarr.length == 3) { if (plinkarr[1] == 'page') { const page = MF_PagePool.getPage(plinkarr[2]); if (page) { if (page.eid == mf_main.editorController.page.eid) { obj.select = true; obj.highlightItem = false; obj.count = i; } } } } }obj.linkcount++; } } } return obj; },
    assignMultiLink(component) { if (component.ALLOW_MULTILINK && component.pageSetLink) { if (component.linkArray) { $(`.${component.eid}_itemCls`).off('click'); component.assignedLinkItems = new Object(); for (const key in component.linkArray) { const num = parseInt(key); if (component.tempLinkItems[num]) { const domID = component.tempLinkItems[num]; const link = component.linkArray[key]; component.assignedLinkItems[domID] = link; $(`.${domID}`).click(function (e) { if (mf_main.editorController.EDITOR) { return; } const link = component.assignedLinkItems[$(this).attr('data-cls')]; if (link) { const linkarr = link.split(':--:'); if (linkarr.length == 3) { if (linkarr[1] == 'page') { const page = MF_PagePool.getPage(linkarr[2]); if (page) { mf_main.editorController.viewPage(page); } } if (linkarr[1] == 'web') { window.open(linkarr[2], '_blank'); } } } }); } } } } else { component.linkObj = null; } },
  };
}()); const MF_IDConverter = (function () {
  canvasDictionary = new Array(); rectangle = 0; triangle = 0; circle = 0; image = 0; canvas = 0; codeblock = 0; ellipse = 0; text = 0; simpletext = 0; button = 0; return {
    reset() { canvasDictionary = new Array(); rectangle = 0; triangle = 0; circle = 0; image = 0; canvas = 0; codeblock = 0; ellipse = 0; text = 0; simpletext = 0; button = 0; }, putCanvasID(cname, cid) { canvas++; canvasDictionary[cid] = `Canvas_${canvas.toString()}`; }, getCanvasID(eid) { return canvasDictionary[eid]; }, getID(type) { if (type == 'MF_Rectangle') { rectangle++; return type + rectangle.toString(); } if (type == 'MF_Circle') { circle++; return type + circle.toString(); } if (type == 'MF_Triangle') { triangle++; return type + triangle.toString(); } if (type == 'MF_Text') { text++; return type + text.toString(); } if (type == 'MF_SimpleText') { simpletext++; return type + simpletext.toString(); } if (type == 'MF_Button') { button++; return type + button.toString(); } if (type == 'MF_Ellipse') { ellipse++; return type + ellipse.toString(); } if (type == 'MF_CodeBlock') { codeblock++; return type + codeblock.toString(); } if (type == 'MF_ImageComp') { image++; return type + image.toString(); } return MF_Utils.guidGenerator(); },
  };
}()); function MF_ComponentList() { const thisClass = this; this.compArray = new Array(); this.cacheSettings = new Object(); this.loadedComponentCode = new Object(); this.categories = new Array(); this.currentCategory = 'featured'; this.featuredComponents = new Array(); this.featureLoaded = false; this.cacheCategory = new Object(); this.settingsScrollPos = new Object(); this.categoryListed = false; this.constructor = function () {}; this.addComponentHandler = function (e) { let comp = null; for (let i = 0; i < thisClass.compArray.length; i++) { const item = thisClass.compArray[i]; if ($(`#mfComponentItem_${item.n}`).css('display') == 'block') { comp = item; break; } } if (comp) { let offsetXPos = 0; let offsetYPos = 0; const scrollTop = document.getElementById('mfEditorHolder').scrollTop; const scrollLeft = document.getElementById('mfEditorHolder').scrollLeft; offsetYPos = offsetYPos + scrollTop + 200; offsetXPos = offsetXPos - $('#mfContainerPage').css('left').replace('px', '') + scrollLeft + 200; mf_main.componentList.invokeComponent(comp.n, 'new', offsetXPos, offsetYPos); } }; this.getFontByHTMLID = function (pid) { let i = 0; for (i = 0; i <= mf_main.editorController.fontController.fontArray.length - 1; i++) { const item = mf_main.editorController.fontController.fontArray[i]; if (`mfFontItem${item.id}` == pid) { return item; break; } } return null; }; this.compLoadHandler = function (e) { const type = $(this).attr('data-compid'); const comppath = MF_Global.getCompPath(); if (!thisClass.loadedComponentCode[type]) { $.cachedScript(`${comppath + type}.js`).done((script, textStatus) => { thisClass.loadedComponentCode[type] = true; }); } }; this.invokeComponent = function (type, loadtype, offsetXPos, offsetYPos, imageid) { let component = null; $('#mfCompPlaceholder').remove(); if (thisClass.loadedComponentCode[type]) { if (loadtype != 'noload') { component = thisClass.getComponentObj(type); } if (loadtype == 'new') { mf_main.editorController.loadInvokedComponent(component, offsetXPos, offsetYPos, imageid); } return component; } const comppath = MF_Global.getCompPath(); if (loadtype == 'new') { thisClass.addPlaceHolderComponent(offsetXPos, offsetYPos); }$.cachedScript(`${comppath + type}.js`).done((script, textStatus) => { if (loadtype != 'noload') { component = thisClass.getComponentObj(type); }thisClass.loadedComponentCode[type] = true; if (loadtype != 'noload') { $('#mfCompPlaceholder').remove(); } if (loadtype == 'new') { mf_main.editorController.loadInvokedComponent(component, offsetXPos, offsetYPos, imageid); } }); }; this.invokeComponentsSrc = function (arr, page, paste) { if (arr.length == 0) { if (paste) { mf_main.editorController.editManager.pasteComponent(true, true, false, true); $('#mfCompPlaceholder').remove(); } else { mf_main.editorController.loadPageData(page); } } else { const newarr = new Array(); for (let l = 0; l < arr.length; l++) { newarr.push(`${arr[l]}.js`); } const comppath = MF_Global.getCompPath(); $.getMultiScripts(newarr, comppath).done(() => { for (let k = 0; k < arr.length; k++) { thisClass.loadedComponentCode[arr[k]] = true; } if (paste) { mf_main.editorController.editManager.pasteComponent(true, true, false, true); $('#mfCompPlaceholder').remove(); } else { mf_main.editorController.loadPageData(page); } }); } }; this.getComponentObj = function (type) { let component = null; component = new window[type](); return component; }; } function MF_CommentController() { const thisClass = this; const startPos = new Object(); const draggedPos = new Object(); let hammer; const dstart = false; const leftButtonDown = false; const touchX = -1; const touchY = -1; this.commentCollection = new ArrayCollection(); this.selectedComment = null; this.uploadFileTemp = null; this.replyUploadFileTemp = null; this.replyEnableHide = true; const newFeedbackObj = null; this.noteAnnotateID = '_leftarrowcvs'; this.noteComp = null; this.noteArrowDirection = 'left'; this.NOTEANNOTATEMODE = false; this.cachedPageComments = new Object(); this.constructor = function () {}; this.setNoteArrow = function (sx, sy, noteid, notecomp, direction) { startPos.x = sx; startPos.y = sy; draggedPos.x = -1; draggedPos.y = -1; thisClass.noteAnnotateID = noteid; thisClass.leftButtonDown = true; thisClass.noteComp = notecomp; thisClass.NOTEANNOTATEMODE = true; thisClass.noteArrowDirection = direction; }; this.drawAndPlaceNoteAnnotation = function (endx, endy, arrowid, direction, lx, ly) { var direction = 'topLeft'; let stx = startPos.x; let sty = startPos.y; if (lx != null) { stx = lx; } if (ly != null) { sty = ly; } const ctx_Div = (document.getElementById(arrowid)).getContext('2d'); ctx_Div.clearRect(0, 0, $(`#${arrowid}`).width(), $(`#${arrowid}`).height()); let newX = endx + 5; let newY = endy + 5; let minusY = false; let minusX = false; if (sty > endy) { $(`#${arrowid}`).height(sty - endy); } else { $(`#${arrowid}`).height(endy - sty); newY = endy - $(`#${arrowid}`).height(); minusY = true; } if (stx > endx) { $(`#${arrowid}`).width(stx - endx); } else { $(`#${arrowid}`).width(endx - stx); newX = endx - $(`#${arrowid}`).width(); minusX = true; } if (minusX && minusY) { direction = 'downRight'; } if (minusX && !minusY) { direction = 'topRight'; } if (!minusX && minusY) { direction = 'downLeft'; } if (direction == 'topLeft' || direction == 'downLeft') { if ($(`#${arrowid}`).width() < 30) { $(`#${arrowid}`).width($(`#${arrowid}`).width() + 20); } if ($(`#${arrowid}`).height() < 30) { $(`#${arrowid}`).height($(`#${arrowid}`).height() + 20); } } else { $(`#${arrowid}`).width($(`#${arrowid}`).width()); } let nx = newX; if (mf_main.editorController.sidebarShow && !mf_main.RENDER) { if (direction == 'left') { nx -= 300; } else { nx -= 320; } } else if (direction == 'left') { nx -= 0; } else { nx -= 60; } let ny = newY; if (!mf_main.RENDER) { nx += $('#mfEditorHolder').scrollLeft(); ny += $('#mfEditorHolder').scrollTop(); }$(`#${arrowid}`).css({ position: 'absolute', top: ny, left: nx }); const c = document.getElementById(arrowid); c.width = $(`#${arrowid}`).width(); c.height = $(`#${arrowid}`).height(); if (direction == 'topLeft') { thisClass.drawAnnotationNoteArrow($(`#${arrowid}`).width(), $(`#${arrowid}`).height(), 10, 10, arrowid); } if (direction == 'downRight') { thisClass.drawAnnotationNoteArrow(0, 0, $(`#${arrowid}`).width() - 10, $(`#${arrowid}`).height() - 10, arrowid); } if (direction == 'topRight') { thisClass.drawAnnotationNoteArrow(0, $(`#${arrowid}`).height(), $(`#${arrowid}`).width() - 10, 10, arrowid); } if (direction == 'downLeft') { thisClass.drawAnnotationNoteArrow($(`#${arrowid}`).width(), 0, 10, $(`#${arrowid}`).height() - 10, arrowid); } }; this.drawAnnotationNoteArrow = function (start_x, start_y, end_x, end_y, arrowid) { const ctx_Div = (document.getElementById(arrowid)).getContext('2d'); thisClass.drawArrow(start_x, start_y, end_x, end_y, ctx_Div, 'rgba(255, 0, 0, 1)'); }; this.placeNoteAnnotation = function (notepointid, notearrowid, direction, x, y, comp) { if (mf_main.REVISION) { return; }$(`#${notearrowid}`).css('display', 'block'); $(`#${notearrowid}`).width(0); $(`#${notearrowid}`).height(0); const rect = MF_Utils.localToGlobal(document.getElementById(notepointid)); let stx = rect.left - comp.x + 20; let sty = rect.top - comp.y + 20; if (!mf_main.RENDER) { stx -= $('#mfEditorHolder').scrollLeft(); sty -= $('#mfEditorHolder').scrollTop(); } else { stx = stx - 321 - 280; } const imageref = 'mfPageArea'; const gcoord = MF_Utils.localToGlobalPoint(parseInt(x), parseInt(y), imageref); if (!mf_main.RENDER) { gcoord.x -= $('#mfEditorHolder').scrollLeft(); gcoord.y -= $('#mfEditorHolder').scrollTop(); } else { gcoord.x = gcoord.x - 321 - 280; }thisClass.drawAndPlaceNoteAnnotation(gcoord.x - comp.x, gcoord.y - comp.y, notearrowid, direction, stx, sty); }; this.drawAnnotationArrow = function (start_x, start_y, end_x, end_y) { const ctx_Div = (document.getElementById('mfAnnotateArrow')).getContext('2d'); thisClass.drawArrow(start_x, start_y, end_x, end_y, ctx_Div, 'rgba(255, 0, 0, 1)'); }; this.drawArrow = function (start_x, start_y, end_x, end_y, ctx_Arrow, arrowColor) { const asize = 30; const apoint = asize - 5; const angle1 = (Math.PI) / 8; const angle2 = (15 * Math.PI) / 8; if ((end_y > start_y) && (end_x > start_x)) { var slope_sign = 1; var x_sign = -1; } if ((end_y < start_y) && (end_x < start_x)) { var slope_sign = 1; var x_sign = 1; } if ((end_y < start_y) && (end_x > start_x)) { var slope_sign = -1; var x_sign = -1; } if ((end_y > start_y) && (end_x < start_x)) { var slope_sign = -1; var x_sign = 1; } if (end_y == start_y) { var slope_sign = 1; var x_sign = -((end_x - start_x) / Math.abs(end_x - start_x)); } const arrow_height = Math.abs(end_y - start_y); const arrow_width = Math.abs(end_x - start_x); ctx_Arrow.shadowOffsetX = 0; ctx_Arrow.shadowOffsetY = 2; ctx_Arrow.shadowBlur = 10; ctx_Arrow.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx_Arrow.strokeStyle = arrowColor; ctx_Arrow.moveTo(start_x, start_y); ctx_Arrow.lineTo(end_x, end_y); ctx_Arrow.fillStyle = arrowColor; if (arrow_width != 0) { var slope = slope_sign * (arrow_height / arrow_width); let d = asize; var x = x_sign * (Math.sqrt((d * d) / (1 + (slope * slope)))); var y = slope * x; d = apoint; var x3 = x_sign * (Math.sqrt((d * d) / (1 + (slope * slope)))); var y3 = slope * x3; } else { const y_sign = -((end_y - start_y) / Math.abs(end_y - start_y)); var x = 0; var y = y_sign * asize; var x3 = 0; var y3 = y_sign * apoint; }ctx_Arrow.save(); ctx_Arrow.translate(end_x, end_y); const x1 = (x * Math.cos(angle1)) - (y * Math.sin(angle1)); const y1 = (x * Math.sin(angle1)) + (y * Math.cos(angle1)); const x2 = (x * Math.cos(angle2)) - (y * Math.sin(angle2)); const y2 = (x * Math.sin(angle2)) + (y * Math.cos(angle2)); const x4 = (x1 + x3) / 3; const y4 = (y1 + y3) / 3; const x5 = (x3 + x2) / 3; const y5 = (y3 + y2) / 3; const s_x = x_sign * arrow_width; const s_y = slope * s_x; ctx_Arrow.fillStyle = arrowColor; ctx_Arrow.strokeStyle = arrowColor; ctx_Arrow.beginPath(); ctx_Arrow.moveTo(0, 0); ctx_Arrow.lineTo(x1, y1); ctx_Arrow.lineTo(x3, y3); ctx_Arrow.lineTo(x2, y2); ctx_Arrow.moveTo(x3, y3); ctx_Arrow.lineTo(x4, y4); ctx_Arrow.lineTo(s_x, s_y); ctx_Arrow.lineTo(x5, y5); ctx_Arrow.closePath(); ctx_Arrow.fill(); ctx_Arrow.shadowOffsetX = 0; ctx_Arrow.shadowOffsetY = 0; ctx_Arrow.shadowBlur = 0; ctx_Arrow.shadowColor = 'rgba(0, 0, 0, 0)'; ctx_Arrow.fillStyle = arrowColor; ctx_Arrow.beginPath(); ctx_Arrow.moveTo(x3, y3); ctx_Arrow.lineTo(x4, y4); ctx_Arrow.lineTo(s_x, s_y); ctx_Arrow.lineTo(x5, y5); ctx_Arrow.closePath(); ctx_Arrow.fill(); ctx_Arrow.shadowOffsetX = 0; ctx_Arrow.shadowOffsetY = 2; ctx_Arrow.shadowBlur = 10; ctx_Arrow.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx_Arrow.beginPath(); ctx_Arrow.moveTo(x4, y4); ctx_Arrow.lineTo(s_x, s_y); ctx_Arrow.restore(); }; this.hideAnnotationPointer = function () { thisClass.clearCommentSelection(); $('#mfAnnotateArrow').css('display', 'none'); thisClass.selectedComment = null; draggedPos.x = -1; draggedPos.y = -1; }; }
